#!/usr/bin/python


from __future__ import print_function

import sys
import re
import sqlite3
from subprocess     import Popen, PIPE

class IdStore:
    def __init__(this, db):
        this.__con = sqlite3.connect(db)

        try:
            cur = this.__con.execute('select Version from Version;')
            row = cur.fetchone()
            version = row[0]
        except:
            version = 0

        prev_version = version

        if version == 0:
            version += 1
            this.__con.execute('create table Version(Version INT);')
            this.__con.execute('create table TagDetail(Series TEXT, Source TEXT, Version TEXT, Tag TEXT, Id TEXT, TidLink TEXT);')
            this.__con.execute('create table IdDetail(Id TEXT, Cid Text, Tid INTEGER, Iorder INTEGER, Frevert BOOLEAN DEFAULT 0, Foverlay DEFAULT 0);')
            this.__con.execute('create table TitleId(Title TEXT, Tid INTEGER, Id TEXT);')
            this.__con.execute('insert into Version(Version) values (1);')
            this.__con.execute('create index IdDetailIdx_Id on IdDetail(Id);')
            this.__con.execute('create index IdDetailIdx_Cid on IdDetail(Cid);')
            this.__con.execute('create index TitleIdIdx_Title on TitleId(Title);')
            this.__con.commit()

        if version == 1:
            # Schema 2: add a Valid flag for TagDetail entries.
            version += 1
            this.__con.execute('update Version set Version=?;', (version,))
            this.__con.execute('alter table TagDetail add Valid BOOLEAN DEFAULT 1;')
            this.__con.commit()

        if version == 2:
            # Schema 3: ROWID can be reassigned during a vacuum.
            # Upgrade it to a primary key Tid.  Note that you cannot
            # add a PRIMARY KEY so we have to rebuild the table
            # and copy the data over.
            version += 1
            this.__con.execute('update Version set Version=?;', (version,))
            this.__con.execute('alter table TagDetail rename to TagDetail_old;')
            this.__con.execute('create table TagDetail(Tid INTEGER PRIMARY KEY AUTOINCREMENT, Series TEXT, Source TEXT, Version TEXT, Tag TEXT, Id TEXT, TidLink TEXT, Valid BOOLEAN DEFAULT 1);')
            this.__con.execute('insert into TagDetail (Tid, Series, Source, Version, Tag, Id, TidLink, Valid) select ROWID, Series, Source, Version, Tag, Id, TidLink, Valid from TagDetail_old;')
            this.__con.execute('drop table TagDetail_old;')
            this.__con.commit()

        if prev_version != version:
            print("Updated schema from version", prev_version, "to", version, file=sys.stderr)

        this.recalc_rids()


    def recalc_rids(this):
        this.__tag_rids = {}

        tags = []
        commit_link = {}

        # Pick up the previous link for every existing TagDetail entry.
        cur = this.__con.execute('select Tid,Series,Source,Version,Id,TidLink from TagDetail;')
        for row in cur:
            (r_rowid, r_series, r_source, r_version, r_id, r_tidprev) = row

            if r_rowid == r_tidprev:
                continue
            if r_tidprev:
                commit_link[int(r_rowid)] = int(r_tidprev);

        # We potentially have multiple entries only the "newest" of which is valid.  Ensure we
        # always take the valid one if there is one.
        cur = this.__con.execute('select Tid,Series,Source,Version,Id,TidLink,Valid from TagDetail order by Valid asc;')
        for row in cur:
            (r_rowid, r_series, r_source, r_version, r_id, r_tidprev, r_valid) = row
            rowid = r_rowid

            rids = []
            while rowid != None:
                ##print(rowid, commit_link.get(int(rowid), None))
                rids.append(str(rowid))
                rowid = commit_link.get(int(rowid), None)

            #print(r_valid, r_series, r_source, r_version, rids)
            this.__tag_rids[(r_series, r_source, r_version)] = rids
            this.__tag_rids[r_rowid] = rids
        
        ##print(this.__tag_rids)
        ##print(this.__tag_rids[('lucid', 'linux', 'pending')])


    def commit(this):
        this.__con.commit();


    # Look through the output of git log for commit references, recording the
    # local sha representing those passed in wanted.
    log_commit = re.compile(r'^commit\s([0-9a-f]{40})')
    # commit SHA1 upstream
    log_shaA = re.compile(r'commit\s+([0-9a-f]{40})\s+upstream')
    # cherry picked from commit SHA1
    # backported from commit SHA1
    log_shaB = re.compile(r'(?i)(?:(?:cherry(?:-|\s+)picked|back(?:-|\s*)port(?:ed)?)\s+from\s+(?:(?:\S+\s+)?commit\s+)?|upstream(?:-|\s+)commit[:\s]\s*|commit\s+upstream\s+)([0-9a-f]{40})\b')
    # Change-Id: ID
    log_shaC = re.compile(r'Change-Id: (I[0-9a-f]+)')
    # Title of the commit
    log_title = re.compile(r'^\s\s\s\s(\S.*)$')
    # This reverts commit SHA1
    log_revert = re.compile(r'This\s+reverts\s+commit\s+([0-9a-f]{40})\b')
    # BugLink: <....>/<lp bug#>
    log_buglink = re.compile(r'(?i)BugLink:.*launchpad.net/.*/([0-9]+)')

    def log_shas(this, tid, commits):
        ##print('log_shas', commits)
        cmd = [ 'git', 'log', commits ]
        p = Popen(cmd, stdout=PIPE)

        count = -1
        sha_current = None
        title_seen = True
        revert = []
        for line in p.stdout:
            ##print(line, end='')
            # commit <sha>
            match = this.log_commit.search(line)
            if match:
                sha_current = match.group(1)
                count += 1
                # Note we want to find the title...
                title_seen = False
                # Record this base sha
                this.__con.execute('insert into IdDetail(Id, Tid, Iorder) values (?, ?, ?);',
                    (sha_current, tid, count))
                continue
            if not sha_current:
                continue
            # '    <title>'
            if not title_seen:
                match = this.log_title.search(line)
                if match:
                    title = match.group(1).strip()
                    title_seen = True
                    # sha_current has title title
                    title_safe = None
                    try:
                        title_safe = unicode(title, 'utf-8')
                    except:
                        pass
                    if title_safe:
                        this.__con.execute('insert into TitleId(Title, Tid, Id) values (?, ?, ?);',
                            (title_safe, tid, sha_current))
            # This commit reverts <sha1>
            match = this.log_revert.search(line)
            if match:
                # Look up the Ids contributed by Cid, either they are in a
                # previous tag and we need to insert a revert, or they are not
                # yet seen so we can mark them found and avoid them being inserted.
                # So whatever is there revert otherwise be happy.
                sha = match.group(1)

                revert.append((sha_current, sha, count))

                # Everything else in here is potentially a lie, ignore.
                sha_current = None
                continue
            # <sha1>
            mprefix = ''
            match = this.log_shaA.search(line)
            if not match:
                match = this.log_shaB.search(line)
            if not match:
                match = this.log_shaC.search(line)
            # BugLink
            if not match:
                match = this.log_buglink.search(line)
                mprefix = 'bug#'
            if match:
                sha = mprefix + match.group(1)
                # sha_current mentions and likely is sha
                ##print("IS", sha_current, sha)
                this.__con.execute('insert into IdDetail(Id, Cid, Tid, Iorder, Frevert) values (?, ?, ?, ?, ?);',
                    (sha, sha_current, tid, count, 0))
                continue

        # Handle reverts, after we have everything inserted correctly.
        for rsha, psha, count in reversed(revert):
            ##print("APW: Revert", sha, sha_current, file=sys.stderr)
            this.__con.execute('insert into IdDetail(Id, Cid, Tid, Iorder, Frevert) values (?, ?, ?, ?, ?);',
                (psha, rsha, tid, count, 1))

            rids = this.__tag_rids[tid]
            cur = this.__con.execute('select Id,Frevert from IdDetail where Cid=? and Tid in (' + ','.join(rids) + ');', (psha,));
            for row in cur:
                (sha, revert) = row
                ##print("APW: Revert", sha, sha_current, file=sys.stderr)
                this.__con.execute('insert into IdDetail(Id, Cid, Tid, Iorder, Frevert) values (?, ?, ?, ?, ?);',
                    (sha, rsha, tid, count, 1 if revert == 0 else 1))


    def log_base(this, series, source, commits):
        ##print('log_base', commits)
        # We do _not_ want tags to point to tags with the exact same commit
        # as this leads us to build complex graphs we can never clean.
        cmd = [ 'git', 'log', '--pretty=format:%H', commits + '^' ]
        p = Popen(cmd, stdout=PIPE)

        #print("LOG_BASE FIND", series, source, commits)
        row = None
        for line in p.stdout:
            # Avoid connecting us to pending tips as those are notoriously fungible.
            cur = this.__con.execute('select Tid,Tag,Id,Series,Source from TagDetail where Id=? and Valid=1 and Version!="pending" order by Tid asc', (line.strip(),))
            (r_tid, r_tag, r_id, r_series, r_source) = (None, None, None, None, None)
            for row in cur:
                (r_tid, r_tag, r_id, r_series, r_source) = row
                #print("LOG_BASE FOUND", r_tid, r_tag, r_id, r_series, r_source)
                if r_series == series and r_source == source:
                    break
            cur.close()

            if r_tid:
                break
        if row:
            #print("LOG_BASE PICKED", r_tid, r_tag, r_id, r_series, r_source)
            return (r_tid, r_tag, r_id)
        else:
            return (None, None, None)


    def git_tag_detail(this, tag):
        cmd = [ 'git', 'log', '-1', '--format=%H', tag ]
        p = Popen(cmd, stdout=PIPE)
        commit = None
        for line in p.stdout:
            commit = line.strip()
        p.terminate()

        ##print('git_tag_detail', tag, commit)

        return commit


    def tag_tid_invalidate(this, tid):
        cur = this.__con.execute("select Series,Source,Version,Tag from TagDetail where Tid=?", (tid,))
        row = cur.fetchone()
        cur.close()
        (series, package, version, tag) = row
        print(series, package, version, "invalidating", tag, tid, file=sys.stderr)

        # Invalidate ourselves.
        this.__con.execute("update TagDetail set Valid=0 where Tid=?", (tid,))


    def tag_tid_clean(this):
        ##print('tag_tid_clean')

        # Look through all the tags looking at the equivalent 
        # Look at all invalid tags and see if they have references.
        changed = True
        n = 0
        while changed:
            n += 1
            changed = False
            cur = this.__con.execute("select Tid from TagDetail where Valid=0 order by Tid desc;")
            for row in cur:
                if this.tag_tid_clean_unreferenced(row[0], n):
                    changed = True
            cur.close()

        this.commit()

    def tag_tid_clean_unreferenced(this, tid, iteration):
        ##print('tag_tid_clean_unreferenced', tid)

        # Look and see if we have any dependent rows.
        dependents = []
        dependents_live = []
        cur = this.__con.execute("select Tid,Valid,Series,Source,Version,Tag from TagDetail where TidLink=?", (tid,))
        for row in cur:
            if row[1] == 1:
                dependents_live.append(row[0:5])
                
            dependents.append(row[0])
            break
        cur.close()

        # Purge ourselves.
        cur = this.__con.execute("select Series,Source,Version,Tag from TagDetail where Tid=?", (tid,))
        row = cur.fetchone()
        cur.close()
        (series, package, version, tag) = row
        if len(dependents) > 0:
            if len(dependents_live) and iteration == 1:
                print(series, package, version, "referenced", tag, tid, dependents, file=sys.stderr)
            return False

        print(series, package, version, "purging", tag, tid, file=sys.stderr)

        this.__con.execute('delete from IdDetail where Tid=?;', (tid,))
        this.__con.execute('delete from TagDetail where Tid=?;', (tid,))
        this.__con.execute('delete from TitleId where Tid=?;', (tid,))

        return True


    def tag_detail_check(this, series, source, version, tag):
        ##print('tag_detail_check', series, source, version, tag)

        commit_tag = this.git_tag_detail(tag)

        cur = this.__con.execute('select Id,Tid from TagDetail where Series=? and Source=? and Tag=? and Valid=1;', (series, source, tag))
        row = cur.fetchone()
        cur.close()

        if not row:
            ##print('tag_detail_check no entry')
            return False

        if row[0] != commit_tag:
            ##print('tag_detail_check missmatch', row[0], commit_tag)
            this.tag_tid_invalidate(row[1])
            return False

        return True


    def tag_detail_add(this, series, source, version, tag, p_tid):
        ##print('tag_detail_add', series, source, version, tag, p_tid)

        commit_tag = this.git_tag_detail(tag)

        ##print('tag_detail_add APW', series, source, version, tag, prev, commit_tag, commit_prev)

        cur = this.__con.cursor()
        cur.execute('insert into TagDetail(Series, Source, Version, Tag, Id, TidLink) values (?, ?, ?, ?, ?, ?);',
            (series, source, version, tag, commit_tag, p_tid))
        tid = cur.lastrowid;
        cur.close()

        this.recalc_rids()

        return tid


    def package_tags_validate(this, series, package, vertags):
        changed = False
        cur = this.__con.execute("select Tid,Version,Tag from TagDetail where Series=? and Source=?", (series, package))
        for row in cur:
            (tid, version, tag) = row
            if (tag, version) not in vertags:
                changed = True
                print(series, package, version, "outdated", tag, file=sys.stderr)
                this.tag_tid_invalidate(tid)
        cur.close()

        this.commit()

        return changed


    def package_update(this, series, package, version, tag):
        if this.tag_detail_check(series, package, version, tag):
            return False
        
        print(series, package, version, "scanning", tag, file=sys.stderr)
        (p_tid, p_tag, prev) = this.log_base(series, package, tag)
        print(series, package, version, "scanning", ((p_tag + '..') if p_tag else '') + tag, p_tid, file=sys.stderr)
        tid = this.tag_detail_add(series, package, version, tag, p_tid)
        this.log_shas(tid, ((prev + '..') if prev else '') + tag)

        this.commit()

        return True


    def package_has(this, series, package, version, commit):
        rids = this.__tag_rids[(series, package, version)]

        # Order by Tid so we see the newest record in our version first,
        # ordering of purges and Tid assignment assure us that a ancestor
        # tag will _always_ have a lower Tid than its decendent.
        cur = this.__con.cursor()
        if debug:
            print('select Id,Frevert from IdDetail where Id=? and Tid in (' + ','.join(rids) + ') order by Tid desc, Iorder;')
        cur.execute('select Id,Frevert from IdDetail where Id=? and Tid in (' + ','.join(rids) + ') order by Tid desc, Iorder;',
            (commit,))
        row = cur.fetchone()
        cur.close()

        # If this is a revert then we really do not have it.
        if row and row[1] == 1:
            row = None

        ##if series == 'lucid' and package == 'linux':
        ##    print('package_has', series, package, version, commit, row)
        return row


    def package_tag_base(this, series, package, version):
        rids = this.__tag_rids[(series, package, version)]

        # It is possible to have two or more tips at the same point such as occurs
        # when we have a master-next which is still pointing at the previous tag.
        # When we are looking for an implied base we want to find a tip which is
        # not for our package.
        cur = this.__con.cursor()
        cur.execute('select series,source,version,tag from TagDetail where Tid in (' + ','.join(rids) + ') order by Tid desc;')
        (s, p, v, t) = (None, None, None, None)
        for row in cur:
            (s, p, v, t) = row
            if debug:
                print("package_tag_base:", series, package, version, "try", s, p, v, t)
            if s != series or p != package:
                break
        cur.close()
        if s == series and p == package:
            (s, p, v, t) = (None, None, None, None)
        return (s, p, v, t)


    def __overlay_add(this, tid, cid, sha, revert, order):
        ##print("__overlay_add", tid, cid, sha, revert, file=sys.stderr)
        this.__con.execute('insert into IdDetail(Id, Cid, Tid, Iorder, Frevert, Foverlay) values (?, ?, ?, ?, ?, ?);',
                (sha, cid, tid, order, revert, 1))


    def overlay_cmd_title(this, title, shas):
        ##print("overlay_cmd_title", title, shas, file=sys.stderr)
        cur = this.__con.cursor()
        cur.execute('select Tid,Id from TitleId where Title=?;', (title,))
        for row in cur:
            (tid, commit) = row
            this.overlay_cmd_shamap(commit, shas)
        cur.close()

    def overlay_cmd_unpublished_version(this, version):
        pass

    def overlay_cmd_shamap(this, fix, shas):
        ##print("overlay_cmd_shamap", fix, shas, file=sys.stderr)
        cur = this.__con.execute('select Tid,Frevert,Iorder from IdDetail where Id=? and Foverlay=0;', (fix,))
        for row in cur:
            (tid, revert, order) = row
            for sha in shas:
                this.__overlay_add(tid, fix, sha, revert, order)
        cur.close()


    def overlay_update(this, overlays):
        # Read in the any corrective overlays.
        this.__con.execute('delete from IdDetail where Foverlay=?', (1,))
        with file(overlays) as fh:
            for line in fh:
                if line[0] == '#':
                    continue
                if line[0] == ':':
                    exec("this.overlay_cmd_" + line[1:])
                    continue
                shas = line.split()
                if len(shas) == 0:
                    continue

                this.overlay_cmd_shamap(shas[0], shas[1:])

        this.__con.commit()


    def dump_bugs(this):
        cur = this.__con.execute("select distinct i.id,series,source,tag from IdDetail i, TagDetail t " + \
                                 "where Tid=t.Tid and i.Id like 'bug#%' and " + \
                                 "Version='pending' order by Tid desc, Iorder;")
        for row in cur:
            (bug, series, source, tag) = row

            print(bug[4:], series, source, tag)
        cur.close()


#                                "$here/cves-applied2" <"$cve_list" "$overlay" \
#                                        "$series" "$cvebranch" \
#                                        $bases $tag_list "$branch" "pending" | \
#                                        tee "$state+cache"
#store = IdStore("/home/apw/test.db")
##store.overlay_update('/home/apw/bzr/cve-tracker/kernel-cve-tracker/active/10autotriage.linux')
#raise "DEBUG"

(store_db, cmd) = sys.argv[1:3]

store = IdStore(store_db)
print("Opened store " + store_db + " successfully", file=sys.stderr)

if cmd == 'rescan-overlay':
    (overlay,) = sys.argv[3:4]
    store.overlay_update(overlay)
    sys.exit(0)

elif cmd == 'clean':
    store.tag_tid_clean()
    sys.exit(0)

elif cmd == 'dump-bugs':
    store.dump_bugs()
    sys.exit(0)

elif cmd not in ('rescan', 'debug'):
    print("Usage: ...", file=sys.stderr)
    sys.exit(1)

debug = False
if cmd == 'debug':
    debug = True

# CMD: rescan
(overlay, series, package) = sys.argv[3:6]
tagvers = sys.argv[6:]

# The list of tags we have is definative for this series, package
# offer it up so we can pre-purge any which we hold which are
# no longer valid.
changed = store.package_tags_validate(series, package, zip(tagvers[::2], tagvers[1::2]))

update_overlay = False
for tag, version in zip(tagvers[::2], tagvers[1::2]):
    if store.package_update(series, package, version, tag):
        update_overlay = True
        changed = True

# Drop any invalid tags which are no longer referenced.
if changed:
    store.tag_tid_clean()

if overlay != '-' and update_overlay:
    store.overlay_update(overlay)

# Read in all of the CVEs and their associated upstream commits.
cves = []

for line in sys.stdin:
    shas = line.split()
    cve_num = shas.pop(0)

    # Work out which package fixes to apply, if there are specific
    # fixes listed use those else use the linux ones.
    pkg_needed = 'linux'
    for sha in shas:
        # <package>:[pre>]need[|need]...
        (pkg, sha) = sha.split(':', 1)

        if pkg == package:
            pkg_needed = package

    needs = []
    for sha in shas:
        # <package>:[pre>]need[|need]...
        (pkg, sha) = sha.split(':', 1)
        if '>' in sha:
            (psha, sha) = sha.split('>')
        else:
            psha = '-'
        # split any alternative fixes for this issue.
        shal = sha.split('|')

        # Only the fixes listed for this package are interesting.
        if pkg != pkg_needed:
            continue

        # If we have any invalid values then morph this into a "need" for something
        # impossible, so we do not lose the CVE.
        valid = True
        if psha != '-' and len(psha) != 40 and not psha.startswith('local-') and not psha.startswith('I'):
            valid = False
        for isha in shal:
            if isha == '-':
                isha = '0000000000000000000000000000000000000000'
            if len(isha) != 40 and not isha.startswith('local-') and not isha.startswith('I'):
                valid = False
                break

        # If this request is invalid, request sha1 0 be installed to get needed status.
        if not valid:
            needs.append(('-', ['0000000000000000000000000000000000000000']))
        else:
            needs.append((psha, shal))

    ##print(cve_num, needselect t2.series,t2.source,t2.version from TagDetail t1, TagDetail t2 where t1.series='upstream' and t1.source='linux-3.19' and t1.version='pending' and t1.TidLink=t2.Tid;
    (ptag, pversion) = tagvers[-2:]

    ##print("CHECKING PREREQ VERSION:", tag, version)

    sptv_list = [ (series, package, v, t) for (t, v) in zip(tagvers[::2], tagvers[1::2]) ]
    (implied_series, implied_package, implied_version, implied_tag) = \
         store.package_tag_base(series, package, tagvers[1])
    if implied_series:
        sptv_list.insert(0, (implied_series, implied_package, implied_version, implied_tag))

    pneeded = False
    pfound = 0
    sfound = 0
    count = 0
    sversion = None
    if debug:
        print("SEARCHING:", cve_num)
    init_shal = None
    for series2, package2, version, tag in reversed(sptv_list):
            count += 1

            all_shal = []
            for (psha, shal) in needs:
                if psha != '-' and not store.package_has(series2, package2, version, psha):
                    continue
                all_shal.append(shal)

            # If we have no pre-requisites ...
            if len(all_shal) == 0:
                pflag = False
                sflag = False

            # We have the pre-requisites, do we have the fixes ...
            else:
                # Keep a list of the shas we need/have.
                if not init_shal:
                    init_shal = all_shal

                pflag = True
                pfound = count
                if count == 1:
                    pneeded = True

                # If we are falling off onto the implied version we only care about
                # whether the prerequisites were present.
                if series != series2 or package != package2:
                    continue

                sflag = True
                for shal in all_shal:
                    one_seen = False
                    for sha in shal:
                        if store.package_has(series2, package2, version, sha):
                            one_seen = True
                    if not one_seen:
                        sflag = False

                if sflag:
                    sfound = count
                    sversion = version

            if debug:
                print("ITERATE:", cve_num, tag, version, pflag, pfound, pneeded, sflag, sfound, sversion)

            # If we have the pre-requisites and not the fixes or
            # we have seen a fix and we are now at a version without, stop.
            if (pflag and not sflag) or (not sflag and sversion):
                break

        ##print(psha, shal)

    wanted = '-'
    if init_shal:
        wanted = ','.join(['|'.join(x) for x in init_shal])
    if pfound == 0:
        print(cve_num, series, package, '-', 'not-affected', '-')
    elif sfound != 0 and pfound > sfound:
        print(cve_num, series, package, wanted, 'released', sversion)
    elif sfound != 0 and pfound <= sfound:
        print(cve_num, series, package, wanted, 'not-affected', sversion)
    elif pneeded:
        print(cve_num, series, package, wanted, 'needed', '-')
    else:
        print(cve_num, series, package, '-', 'not-affected', '-')
