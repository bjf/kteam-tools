#!/usr/bin/python3

import os
import sys
sys.path.append(os.path.realpath(os.path.join(os.path.dirname(__file__), '..', '..', 'libs')))

from distutils.version      import LooseVersion
from ktl.kernel_series      import KernelSeries

print('strict digraph {')
#print(' concentrate=true;')
print(' rankdir=RL; // Left to Right, instead of Top to Bottom')
#print(' node [width="3"]')

nodes_nid = 0
nodes_nids = {}
nid_labels = {}

def labels_to_str(labels):
    modifiers = '; '.join([ l + '="' + v + '"' for l,v in labels.items() ])
    if modifiers == '':
        return ''

    return ' [' + modifiers + ']'


def node_set(node, new_labels):
    global nodes_nid
    global nodes_nids
    global nid_labels

    if node not in nodes_nids:
        nodes_nid += 1
        nodes_nids[node] = nodes_nid

        group = node.split('/')[0]
        label = node.replace('/', '\\n')
        nid_labels[nodes_nid] = { 'group': group, 'label': label }

    nid = nodes_nids[node]
    
    labels = nid_labels[nid]
    labels.update(new_labels)

    return nid


edges = []
def edge_add(start, end, labels):
    global edges
    edges.append((start, end, labels))



def nodes_emit():
    global nodes_nids
    global nid_labels

    groups = {}
    for nid in sorted(nid_labels):
        groups[nid_labels[nid]['group']] = True
        print(' T{nid}{labels}'.format(nid=nid, labels=labels_to_str(nid_labels[nid])))

    #for group in groups:
    #    print("{ rank=same", end='')
    #    for node in sorted(nodes_labels):
    #        if nodes_labels[node]['group'] == group:
    #            print(" T" + str(nodes_nids[node]), end='')
    #    print("}")


def edges_emit():
    global edges
    for (start, end, labels) in edges:
        print(' T{start} -> T{end}{labels}'.format(start=start, end=end, labels=labels_to_str(labels)))


def connection_add(start, link, end):
    start_modifiers = {}
    link_modifiers = {'color': 'grey'}
    if link[0] == 'X':
        start_modifiers.update({'color': 'grey', 'fontcolor': 'grey'})
        link = link[1:]

    if link == '-->':
        link_modifiers.update({'style': 'dashed', 'color': 'orange'})
    elif link == 'copy':
        link_modifiers.update({'color': 'brown', 'dir': 'none', 'label': 'copy'})

    start_nid = node_set(start, start_modifiers)
    end_nid = node_set(end, {})

    edge_add(start_nid, end_nid, link_modifiers)

kernel_series = KernelSeries()
upstreams = set()
for series in sorted(kernel_series.series, key=KernelSeries.key_series_name):
    if not series.supported and not series.development:
        continue
    for source in sorted(series.sources, key=lambda x: x.name):
        if not source.supported:
            continue

        start = "{}/{}".format(source.series.codename, source.name)
        end = None
        versions = source.versions
        if versions:
            upstreams.add(versions[-1])

        if source.copy_forward:
            end = "{}/{}".format(source.copy_forward.series.codename, source.copy_forward.name)
            connection_add(start, 'copy', end)
            continue

        if source.derived_from:
            end = "{}/{}".format(source.derived_from.series.codename, source.derived_from.name)
            connection_add(start, '->', end)
            continue

        if versions:
            end = "mainline/{}".format(versions[-1])
            connection_add(start, '->', end)
            continue

        # We have nothing to join ourselves to ... make a red blob.
        node_set(start, {'color': 'red'})

# Join up the upstreams.
upstreams = sorted(upstreams, key=LooseVersion)
previous = None
for upstream in upstreams:
    if previous:
        connection_add("mainline/{}".format(upstream), '-->', "mainline/{}".format(previous))
    previous = upstream

nodes_emit()
edges_emit()

print('}')
