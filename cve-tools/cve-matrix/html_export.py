#!/usr/bin/python
# -*- coding: utf-8 -*-
# Author: Kees Cook <kees@ubuntu.com>
# Author: Jamie Strandboge <jamie@ubuntu.com>
# Copyright (C) 2005-2010 Canonical Ltd.
#
# This script is distributed under the terms and conditions of the GNU General
# Public License, Version 3 or later. See http://www.gnu.org/copyleft/gpl.html
# for details.

import sys
import re
import cve_lib
from urllib import quote
from cgi import escape
from time import gmtime, strftime

# FIXME: detect and safely quote URLs

# on-demand initialized during pkg exports
map = None

all_releases = cve_lib.releases
all_releases.sort()
releases = [] + all_releases
releases.append('product')

for eol in cve_lib.eol_releases:
    if eol in releases:
        releases.remove(eol)

def html_header(title, description, outfd):
    print >>outfd, '''<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>%s</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="author" content="Canonical Ltd, and others" />
<meta name="description" content="%s" />
<meta name="copyright" content="Canonical Ltd, and others" />
<link rel="StyleSheet" href="../toplevel.css" type="text/css" />
</head>

<body>
<div id="container">
''' % (escape(title), quote(description))

def html_footer(outfd, commit=None):
    print >>outfd, '<p id="w3c">'
    print >>outfd, '  <a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10" alt="Valid XHTML 1.0 Strict" height="31" width="88" style="border: 0;"/></a>'
    print >>outfd, '</p>'
    print >>outfd, '<p class="note"><a href="https://code.launchpad.net/~ubuntu-security/ubuntu-cve-tracker/master">Updated</a>: %s' % (strftime("%F %T UTC", gmtime())),
    if commit:
        print >>outfd, ' (commit <a href="http://bazaar.launchpad.net/~ubuntu-security/ubuntu-cve-tracker/master/revision/%d">%d</a>)' % (int(commit), int(commit)),
    print >>outfd, '</p>'
    print >>outfd, '</div>' # end of "container" div from header

    print >>outfd, '<div id="footer">'
    print >>outfd, '&copy; Canonical Ltd. 2007-%s' % (strftime("%Y", gmtime()))
    print >>outfd, '</div>'
    print >>outfd, '</body>'
    print >>outfd, '</html>'

def htmlize_cve(cvefile, outfd, commit=None):
    data = cve_lib.load_cve(cvefile)

    is_retired = False
    if re.match('^%s' % cve_lib.retired_dir,cvefile):
        is_retired = True

    #import pprint
    #pp = pprint.PrettyPrinter(indent=4)
    #pp.pprint(data)

    cve = data['Candidate']

    html_header('%s in Ubuntu' % (cve), 'Ubuntu CVE Entry', outfd)

    # CVE cross links
    heading = quote(cve)
    if is_retired:
        heading += ' (retired)'
    print >>outfd, '<h2 class="cve">%s</h2>' % (heading)

    # Handle "free-form" text
    for field in ['Priority','Description','Ubuntu-Description','References','Bugs','Notes','Assigned-to']:
        if not data.has_key(field):
            continue
        text = data[field].strip()
        if len(text) == 0:
            continue

        escaped_body = ""
        for line in text.split('\n'):
            if (field == "References" or field == "Bugs") and re.match('^http[s]?://', line):
                escaped_body += '<a href="%s">%s</a><br />' % (quote(escape(line), ':/?&;='), escape(line))
            else:
                space = ''
                if field == 'Notes':
                    space = '&nbsp;'
                escaped_body += '%s%s<br />' % (space, escape(line))

        value_class = "value"
        if field == 'Notes':
            value_class = 'notes-value'


        if field == "Priority":
            escaped_body = escaped_body.capitalize()
            if escape(line).lower() == "negligible":
                value_class = "negligible-value"
            elif escape(line).lower() == "low":
                value_class = "low-value"
            elif escape(line).lower() == "medium":
                value_class = "medium-value"
            elif escape(line).lower() == "high":
                value_class = "high-value"
            elif escape(line).lower() == "critical":
                value_class = "critical-value"
            else:
                value_class = "value"

        print >>outfd, '<div class="item"><div class="field">%s</div> <div class="%s">%s</div></div>' % (escape(field),value_class,escaped_body)

    # Handle package logic
    for pkg in data['pkgs']:
        print >>outfd, '<div class="pkg">'
        if 'product' in data['pkgs'][pkg].keys():
            print >>outfd, '<div class="field">Package</div><div class="value">Source tree: ' + \
                '<a href="%s">%s</a>' % (escape(cve_lib.product_kernels[pkg][0]), escape(cve_lib.product_kernels[pkg][0])) + \
                '</div>'
        else:
            print >>outfd, '<div class="field">Package</div><div class="value">Source: ' + \
                '<a href="http://people.canonical.com/~ubuntu-security/cve/pkg/%s.html">%s</a> ' % (quote(pkg),escape(pkg)) + \
                '(' + \
                '<a href="https://launchpad.net/distros/ubuntu/+source/%s">LP</a> ' % (quote(pkg)) + \
                '<a href="http://packages.ubuntu.com/search?suite=all&amp;section=all&amp;arch=any&amp;searchon=sourcenames&amp;keywords=%s">Ubuntu</a> ' % (quote(pkg)) + \
                '<a href="http://packages.qa.debian.org/%s">Debian</a>' % (quote(pkg)) + \
                ')</div>'

        print >>outfd, '<table>'

        # figure out what the development release was based on the releases
        # in the CVE
        cve_devel_release = cve_lib.devel_release
        cve_releases = data['pkgs'][pkg].keys()
        if 'upstream' in cve_releases:
            cve_releases.remove('upstream')
        if 'devel' in cve_releases:
            cve_releases.remove('devel')

        if len(cve_releases) > 0:
            cve_releases.sort()
            try:
                index = all_releases.index(cve_releases[-1]) + 1
                if index < len(all_releases) and all_releases[index]:
                    cve_devel_release = all_releases[index]
            except:
                pass
        if cve_devel_release not in releases:
            cve_devel_release = 'EOL ' + cve_devel_release

        release_list = ['upstream', 'product'] + releases
        for release in release_list:
            relname = release

            if relname == cve_devel_release:
                release = 'devel'

            if not data['pkgs'][pkg].has_key(release):
                continue

            status = data['pkgs'][pkg][release][0]
            notes  = data['pkgs'][pkg][release][1]

            if cve_lib.release_names.has_key(relname):
                release_title = cve_lib.release_names[relname]
            else:
                release_title = relname.capitalize()
                if relname == 'product':
                    release_title = quote(pkg)
            name = '%s' % (escape(release_title))
            if status != 'DNE' and relname != 'upstream' and relname != 'product':
                name = '<a href="https://launchpad.net/ubuntu/%s/+source/%s">%s</a>' % (quote(relname),quote(pkg),escape(release_title))

            status_class = "default"
            if status in ['needed','active','deferred']:
                status_class = "vuln"
            elif status in cve_lib.status_closed:
                status_class = "safe"
            elif status == 'pending':
                status_class = "pending"

            print >>outfd, '<tr><td>%s:</td><td><span class="%s">%s</span>' % (name, status_class, status)
            if len(notes):
                print >>outfd, '(%s)' % (escape(notes))
            print >>outfd, '</td></tr>'
        print >>outfd, '</table>'

        patches = 'Patches_%s' % (pkg)
        if data.has_key(patches):
            entries = data[patches]
            if entries != "":
                print >>outfd, '<div class="patches">Patches:</div>'
                print >>outfd, '<table>'
            for patch in entries.split('\n'):
                if not ':' in patch:
                    continue
                source, url = patch.split(':',1)
                url = url.strip()
                if source == "break-fix" and " " in url:
                    introduced, fixed = url.split(' ',1)
                    if introduced == '-':
                        # First commit to Linux git tree
                        introduced = '1da177e4c3f41524e886b7f1b8a0c1fc7321cac2'
                    print >>outfd, '<tr><td>Introduced by <a href="http://git.kernel.org/linus/%s">%s</a></td><td>Fixed by <a href="http://git.kernel.org/linus/%s">%s</a></td></tr>' % (introduced, introduced, fixed, fixed)
                else:
                    if re.match('^(ftp|http)[s]?://', url):
                        print >>outfd, '<tr><td>%s:</td><td><a href="%s">%s</a></td></tr>' % (escape(source).capitalize(),url.replace('"','%22'),escape(url))
                    else:
                        print >>outfd, '<tr><td>%s:</td><td>%s</td></tr>' % (escape(source).capitalize(),escape(url))
            if entries != "":
                print >>outfd, '</table>'
        print >>outfd, '</div>'

    print >>outfd, '<div class="item">'
    print >>outfd, '<div class="field">More Information</div>'
    print >>outfd, '<ul class="links"><li><a href="http://cve.mitre.org/cgi-bin/cvename.cgi?name=%s">Mitre</a></li><li><a href="http://nvd.nist.gov/nvd.cfm?cvename=%s">NVD</a></li><li><a href="https://launchpad.net/bugs/cve/%s">Launchpad</a></li><li><a href="http://security-tracker.debian.net/tracker/%s">Debian</a></li></ul>' % (quote(cve),quote(cve),quote(cve),quote(cve))
    print >>outfd, '</div>'

    html_footer(outfd, commit)

def htmlTableHeader(headings):
    header = '<tr><th>CVE</th>'
    for heading in headings:
        name = heading
        header += "<th>%s</th>" % (name.capitalize())
    #header += '<th>Links</th><th>Notes</th>'
    header += '</tr>'
    return header

# Produces HTML for a given source package.
def htmlize_package(outfd, pkg, cvefiles, commit=None):
    html_header('%s CVEs in Ubuntu' % (pkg), 'Ubuntu Package CVE Entry', outfd)

    print >>outfd, '<h2 class="pkg">%s</h2>' % (quote(pkg))
    notes = set()

    # Loading the source map is expensive, which is unfortunate.  We will
    # do it only for pkg html output, since the generate-pkg-makefile script
    # is already trying to minimize how much we run this function.
    global map
    if not map:
        import source_map
        map = source_map.load()

    # Merged package reports (linux-source-2.6.15 should appear in
    # linux) only work when a package (linux) does not exist in a given
    # release (dapper) but the replacement does (linux-source-2.6.15).
    # So, figure out which pkg should be used for lookups in each in release:
    pkgname = dict()
    for rel in releases:
        rel_orig = rel
        if rel == cve_lib.devel_release:
            rel = 'devel'
        pkgname[rel_orig] = pkg
        if rel_orig in map and not map[rel_orig].has_key(pkg) and cve_lib.pkg_aliases.has_key(pkg):
            # Aliases: 'linux-source-2.6.15' should appear in 'linux' output
            for alias in cve_lib.pkg_aliases[pkg]:
                if map[rel_orig].has_key(alias):
                    #print >>sys.stderr, "\tfound alias '%s' for '%s'" % (alias, pkg)
                    pkgname[rel_orig] = alias
                    notes.add('CVEs from <a href="%s.html">%s</a> in %s have been merged into this report' % (quote(alias), escape(alias), escape(rel_orig)))
                    break

    # For a given source package, if it is supported for a release, but
    # there is a CVE that is marked as affecting a universe binary only,
    # we need to mark it as "community supported".  Start by building up
    # a map of supportability per-release for the source package.
    starred = False
    src_supported = dict()
    headings = []
    entire_release_starred = set()
    for rel in releases:
        heading = rel
        src_supported[rel] = False
        if pkgname[rel] and rel in map and map[rel].has_key(pkgname[rel]):
            src_supported[rel] = cve_lib.is_supported(map, pkgname[rel], rel)
            if not src_supported[rel]:
                starred = True
                entire_release_starred.add(rel)
                heading += "*"
        headings.append(heading)

    if len(cvefiles) == 0:
        print >>outfd, '<div class="item"><div class="field">%s</div> <div class="%s">%s</div></div>' % ('Status','value','No known vulnerable public CVEs')
    else:
        print >>outfd, '<table>' + htmlTableHeader(headings)
        for cvefile in cvefiles:
            data = cve_lib.load_cve(cvefile)

            # Sort out priority
            priority = cve_lib.contextual_priority(data)[1]
            print >>outfd, '<tr class="%s">' % (quote(priority)),

            # fields...
            # 'pkgs' -> dict(  pkg -> dict(  release ->  (state, notes)   ) )
            cve = data['Candidate']
            #print >>sys.stderr, 'cve: %s' % (cve)
            print >>outfd, '<td class="cve"><a href="http://people.canonical.com/~ubuntu-security/cve/%s">%s</a></td>' % (quote(cve), escape(cve)),
            for rel in releases:
                rel_orig = rel
                if rel == cve_lib.devel_release:
                    rel = 'devel'

                report_pkg = pkgname[rel_orig]

                # Sort out priority override
                priority_override = cve_lib.contextual_priority(data, pkg=report_pkg, rel=rel)[1]
                #print >>sys.stderr, '\tlooking for %s' % (report_pkg)
                if data['pkgs'].has_key(report_pkg) and data['pkgs'][report_pkg].has_key(rel):
                    pkgstatus = data['pkgs'][report_pkg][rel][0]
                    pkgnotes = data['pkgs'][report_pkg][rel][1]
                    pkgclass = pkgstatus
                    #print >>sys.stderr, '\t\tstatus for %s is %s' % (report_pkg, pkgclass)

                    if pkgclass == 'DNE':
                        pkgstatus = "--"
                    if pkgstatus == 'pending' and pkgnotes != '':
                        pkgclass = 'pendingversion'
                    priority_class = ""
                    priority_start = ""
                    priority_end = ""
                    if priority_override != priority:
                        priority_class = " override"
                        priority_start = '<div class="%s">' % (quote(priority_override))
                        priority_end = '</div>'

                    # Sort out supportability override
                    if pkgstatus not in ["--","not-affected"] and \
                       src_supported[rel_orig] and \
                       not cve_lib.is_supported(map, report_pkg, rel_orig, data):
                        starred = True
                        pkgstatus += "*"

                    print >>outfd, '<td class="%s%s">%s%s%s</td>' % (quote(pkgclass), priority_class, priority_start, escape(pkgstatus), priority_end),
                else:
                    print >>outfd, '<td class="DNE">--</td>',
            print >>outfd, '</tr>'
        print >>outfd, '</table>'
        if starred:
            print >>outfd, '<p class="note">* community supported</p>'
        if len(notes) > 0:
            print >>outfd, '<div class="item"><div class="field">Note</div>'
            for note in sorted(notes):
                print >>outfd, '<div class="value">%s</div>' % (note)
            print >>outfd, '</div>'
        print >>outfd, '<div class="item"><div class="field">%s</div> <div class="%s">%s</div></div>' % ('Status','value','%d known public CVEs' % (len(cvefiles)))

    html_footer(outfd, commit)
