#! /usr/bin/python

# Copyright 2013 Canonical Ltd.
# Author: Andy Whitcroft <apw@canonical.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""Allow editing of bugs ..."""

from __future__ import print_function

#from collections import OrderedDict
from optparse import OptionParser
import shlex
import sys

from launchpadlib.launchpad import Launchpad
#from ubuntutools.question import YesNoQuestion

#import lputils

def usage(throw, msg):
    if throw:
        raise BaseException(msg)

def doit(options, msg):
    if not options.quiet:
        if options.dry_run:
            print(msg + " (dry-run)")
        else:
            print(msg)
    return not options.dry_run


def command(options, args):
    ubuntu = options.launchpad.distributions['ubuntu']
    devel = ubuntu.current_series

    bug = None
    task = None
    chgd = False
    while len(args) > 0:
        cmd = args.pop(0)

        if cmd == 'bug':
            usage(len(cmd) < 1, "bug <bug number>")
            bnum = args.pop(0)

            if bnum.startswith('LP#'):
                bnum = bnum[3:]

            bug = options.launchpad.bugs[bnum]
            #print("BUG: " + str(bug))
        
            task = None
            chgd = False

            if not bug:
                print(bnum + ": Bug not found")
                return

        elif cmd == 'task':
            usage(len(cmd) < 2, "task <series> <source package>")
            usage(bug == None, cmd + ": bug required")
            (series_name, source_name) = (args.pop(0), args.pop(0))

            series = ubuntu.getSeries(name_or_version=series_name)
            series_source = series.getSourcePackage(name=source_name)
            for tsk in bug.bug_tasks:
                if tsk.target_link != series_source.self_link:
                    continue
                task = tsk
                break

            # If there is no specific task there may be a source package task
            # but only if we are talking about the development release.
            if not task and devel.self_link == series.self_link:
                series_source = ubuntu.getSourcePackage(name=source_name)
                for tsk in bug.bug_tasks:
                    if tsk.target_link != series_source.self_link:
                        continue
                    task = tsk
                    break
                
            #print("TASK: " + str(task))
            chgd = False

            if not task:
                print("bug " + str(bug.id) + ": " + series_name + " " + source_name + ": Task not found")
                return


        elif cmd == 'project-task':
            usage(len(cmd) < 2, "project-task <project> <series>")
            usage(bug == None, cmd + ": bug required")
            (project_name, series_name) = (args.pop(0), args.pop(0))

            project = options.launchpad.projects[project_name]
            series = project.getSeries(name=series_name)

            for tsk in bug.bug_tasks:
                if tsk.target_link != series.self_link:
                    continue
                task = tsk
                break

            #print("TASK: " + str(task))
            chgd = False

            if not task:
                print("bug " + str(bug.id) + ": " + project_name + " " + series_name + ": Task not found")
                return


        elif cmd == 'sru':
            usage(len(args) < 1, "sru <activity>")
            usage(bug == None, cmd + ": bug required")
            (project_name, series_name) = ('kernel-sru-workflow', args.pop(0))

            project = options.launchpad.projects[project_name]
            series = project.getSeries(name=series_name)

            for tsk in bug.bug_tasks:
                if tsk.target_link != series.self_link:
                    continue
                task = tsk
                break

            #print("TASK: " + str(task))
            chgd = False

            if not task:
                print("bug " + str(bug.id) + ": " + project_name + " " + series_name + ": Task not found")
                return


        elif cmd == 'sanitise':
            usage(len(cmd) < 1, cmd + " -|<source package>")
            usage(bug == None, cmd + ": bug required")
            source_name = args.pop(0)

            source = None
            if source_name != '-':
                source = ubuntu.getSourcePackage(name=source_name)
                if not source:
                    usage(True, cmd + ": " + source_name + ": source package invalid")

            valid = {
                'ALL':                          [ 'lucid', 'maverick', 'natty', 'oneiric', 'precise', 'quantal', 'raring', 'saucy', 'trusty', 'utopic', 'vivid', 'wily', 'xenial' ],
                'linux':                        [ 'precise', 'trusty', 'utopic', 'vivid', 'wily', 'xenial' ],
                'linux-armadaxp':               [ 'precise' ],
                'linux-lts-backport-maverick':  [ ],
                'linux-lts-backport-natty':     [ ],
                'linux-lts-backport-oneiric':   [ ],
                'linux-lts-quantal':            [ 'precise' ],
                'linux-lts-raring':             [ 'precise' ],
                'linux-lts-saucy':              [ 'precise' ],
                'linux-lts-trusty':             [ 'precise' ],
                'linux-lts-utopic':             [ 'trusty' ],
                'linux-lts-vivid':              [ 'trusty' ],
                'linux-lts-wily':               [ 'trusty' ],
                'linux-lts-xenial':             [ 'trusty' ],
                'linux-ti-omap4':               [ 'precise' ],
                'linux-goldfish':               [ 'vivid' ],
                'linux-manta':                  [ 'vivid' ],
                'linux-mako':                   [ 'vivid' ],
                'linux-flo':                    [ 'vivid' ],
            }
            for key in list(valid):
                key2 = key.replace('linux-', 'linux-signed-')
                valid[key2] = valid[key]

            tasks = {}
            for tsk in bug.bug_tasks:
                target = tsk.target

                if source and target.name != source_name:
                    continue

                #print(target.name)

                # Record this task against the series link, for the untargetted
                # task apply this to devel but take a targetted task in preference.
                series = None
                try:
                    #distro = target.distribution.self_link
                    series = target.distroseries.self_link
                except:
                    pass
                if not series:
                    series_source = devel.getSourcePackage(name=target.name)
                    if series_source not in tasks:
                        tasks[series_source] = tsk
                else:
                    tasks[target] = tsk
                
            affected = {}
            for target in tasks:
                source = target.name
                series = target.distroseries.name
                #print(source, series)
                if series not in valid['ALL']:
                    #print("NO INFORMATION -- ignoring")
                    continue
                if source not in valid:
                    #print("UNKNOWN PACKAGE -- ignoring")
                    continue
                if series in valid[source]:
                    #print("VALID -- ignoring")
                    continue
                #print("BAD")
                affected[target] = tasks[target]

            fixed = {}
            for target in affected:
                tsk = affected[target]

                if tsk.status != 'Invalid':
                    source = target.name
                    series = target.distroseries.name
                    tag = source + "_" + series
                    if tag in fixed:
                        continue
                    fixed[tag] = True
                    if doit(options, source + " " + series + " pushed invalid"):
                        tsk.status = 'Invalid'
                        tsk.lp_save()


        elif cmd == 'tag-list':
            usage(bug == None, cmd + ": bug required")

            for tag in bug.tags:
                print(tag)

        elif cmd == 'tag-remove':
            usage(len(cmd) < 1, "tag-remove <tag>")
            tag_name = args.pop(0)

            if tag_name in bug.tags:
                if doit(options, "tag removed " + tag_name):
                    tags = bug.tags
                    tags.remove(tag_name)
                    bug.tags = tags
                    bug.lp_save()
                chgd = True
            
        elif cmd == 'tag-add':
            usage(len(cmd) < 1, "tag-remove <tag>")
            usage(bug == None, cmd + ": bug required")
            tag_name = args.pop(0)

            if tag_name not in bug.tags:
                if doit(options, "tag added " + tag_name):
                    tags = bug.tags
                    tags.append(tag_name)
                    bug.tags = tags
                    bug.lp_save()
                chgd = True

        elif cmd == 'status':
            usage(len(cmd) < 1, "status <new status>")
            usage(task == None, cmd + ": task required")
            new_status = args.pop(0)
            
            cur_status = task.status
            # applied is Fix Committed but will not roll back from Fix Released
            if new_status in ('applied', 'Fix C/R'):
                if cur_status == 'Fix Released':
                    new_status = 'Fix Released'
                else:
                    new_status = 'Fix Committed'
            if cur_status != new_status:
                if doit(options, "pushed task " + new_status + " from " + cur_status):
                    task.status = new_status
                    task.lp_save()
                chgd = True

        elif cmd == 'assign':
            usage(len(cmd) < 1, "assign <new owner>")
            usage(task == None, cmd + ": task required")
            new_owner = options.launchpad.people[args.pop(0)]
            
            cur_owner = task.assignee

            if cur_owner != new_owner:
                if doit(options, "assigned task " + str(new_owner)):
                    task.assignee = new_owner
                    task.lp_save()
                chgd = True

        elif cmd == 'importance':
            usage(len(cmd) < 1, "importance <new importance>")
            usage(task == None, cmd + ": task required")
            new_importance = args.pop(0)
            
            cur_importance = task.importance

            if cur_importance != new_importance:
                if doit(options, "importance task " + str(new_importance)):
                    task.importance = new_importance
                    task.lp_save()
                chgd = True
        elif cmd == 'comment-if-changed':
            usage(len(cmd) < 1, "comment-if-changed <comment>")
            usage(bug == None, cmd + ": bug required")
            comment = args.pop(0)
            
            if chgd:
                if doit(options, "comment bug " + str(comment)):
                    bug.newMessage(content=comment)


def main():
    options = {}
    parser = OptionParser(
        usage="usage: %prog -s suite [options] package [...]")
    parser.add_option(
        "-l", "--launchpad", dest="launchpad_instance", default="production")
    parser.add_option(
        "-n", "--dry-run", default=False, action="store_true",
        help="only show removals that would be performed")
    parser.add_option(
        "-q", "--quiet", default=False, action="store_true",
        help="keep quiet about actions being taken")
#    parser.add_option(
#        "-d", "--distribution", default="ubuntu",
#        metavar="DISTRIBUTION", help="override in DISTRIBUTION")
#    parser.add_option(
#        "-s", "--suite", metavar="SUITE", help="override in SUITE")
#    parser.add_option(
#        "-e", "--version",
#        metavar="VERSION", help="package version (default: current version)")
#    parser.add_option(
#        "-c", "--command", default='unblock',
#        help="migration hint command (default: unlock)")
#
    options, args = parser.parse_args()

    options.launchpad = Launchpad.login_with(
        "bug-command", options.launchpad_instance, version="devel")

#    # We care about the development series by defaults.
#    if hasattr(options, 'suite'):
#        ubuntu = options.launchpad.distributions['ubuntu']
#        options.suite = ubuntu.current_series.name + '-proposed'

    if len(args) == 1 and args[0] == '-':
        for line in sys.stdin:
            if line.startswith('#'):
                continue
            if not options.quiet:
                print("bug-update: " + line.strip())
            args = shlex.split(line)
            command(options, args)

    else:
        command(options, args)

if __name__ == '__main__':
    main()
