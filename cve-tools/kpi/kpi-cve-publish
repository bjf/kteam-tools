#!/usr/bin/python3

import datetime
from collections import defaultdict

class CollectorRegistry:
    def __init__(self):
        self.collectors = []

    def register(self, collector):
        self.collectors.append(collector)

    def write_to_textfile(self, sample):
        for collector in self.collectors:
            print("# HELP {} {}".format(collector.name, collector.desc))
            print("# TYPE {} {}".format(collector.name, collector.type))
            for sample in collector.collect():
                print("{}{} {}{}".format(collector.name, sample.labels, sample.value, " " + sample.timestamp if sample.timestamp else ""))

class Value:
    def __init__(self, labels, timestamp, value):
        self.labels = labels
        self.timestamp = timestamp
        self.value = value


class Metric:
    def __init__(self, name, description, type, registry=None):
        self.name = name
        self.desc = description
        self.type = type
        self.registry = registry

        self._samples = defaultdict(dict)

        if registry:
            registry.register(self)

    def _labels_string(self, labels):
        if not labels:
            return ''
        labels_str = ','.join([key + '="' + labels[key] + '"' for key in sorted(labels.keys())])
        return '{' + labels_str + '}'

    def set(self, value, labels=None, timestamp=''):
        #print("APW", value, labels, timestamp)
        label_string = self._labels_string(labels)
        self._samples[timestamp][label_string] = Value(value=value, labels=label_string, timestamp=timestamp)

    def _get(self, value, labels=None, timestamp=''):
        label_string = self._labels_string(labels)
        return self._samples[timestamp].get(label_string, Value(value=0, label=label_string, timestamp=timestamp))

    def collect(self):
        for timestamp in sorted(self._samples):
            for labels in sorted(self._samples[timestamp]):
                yield self._samples[timestamp][labels]

    def timestamp(self, timestamp):
        class MetricTimestamp(Gauge):
            def __init__(self, *args, slave, timestamp, **kwargs):
                super().__init__(*args, **kwargs)
                self._slave = slave
                self._timestamp = timestamp

            def set(self, *args, **kwargs):
                return self._slave.set(*args, timestamp=self._timestamp, **kwargs)

        return MetricTimestamp(slave=self, timestamp=timestamp, name=self.name, description=self.desc)

    def labels(self, **labels):
        class MetricLabels(Gauge):
            def __init__(self, *args, slave, labels, **kwargs):
                super().__init__(*args, **kwargs)
                self._slave = slave
                self._labels = labels

            def set(self, *args, **kwargs):
                return self._slave.set(*args, labels=self._labels, **kwargs)

        return MetricLabels(slave=self, labels=labels, name=self.name, description=self.desc)


class Gauge(Metric):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, type='Gauge', **kwargs)


def set_gauges(registry, series_list):
    test_gauge = Gauge('kernel_cves', 'CVE count', registry=registry)

    for series in series_list:
        test_gauge.labels(series=series['name']).set(series['cve_count'])
        test_gauge.timestamp(str(int(datetime.datetime.utcnow().timestamp())*1000)).labels(series=series['name']).set(series['cve_count'])


if __name__ == '__main__':
    import os
    import sys

    series = []
    series.append({
        'name': 'artful',
        'cve_count': 11,
    })
    series.append({
        'name': 'zesty',
        'cve_count': 15,
    })

    registry = CollectorRegistry()
    try:
        set_gauges(registry, series)
    finally:
        registry.write_to_textfile("test")
