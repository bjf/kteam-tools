#!/bin/bash

shopt -s extglob

http_proxy=http://squid.internal:3128/
export http_proxy

PATH=$PATH:$HOME/bin

here=`dirname $0`
case "$here" in
/*) ;;
*)  here="`pwd`/$here" ;;
esac

out="$HOME/cve-autotriage"

cd "$out" || exit 1

wip="cve-tracker-wip"
final="cve-tracker"

cve_list="/tmp/cve-commits.$$"

time="$SECONDS"

echo "*** reset to kernel changes ..."
if [ ! -d "$wip" ]; then
	bzr branch lp:~canonical-kernel-team/ubuntu-cve-tracker/kernel-team/ "$wip" || exit 1
fi
if [ ! -d "$final" ]; then
	bzr branch lp:~canonical-kernel-team/ubuntu-cve-tracker/kernel-team/ "$final" || exit 1
fi

# Perform all the merges application etc in a temporary copy to avoid
# races for consumers.
(
	cd "$out/$wip" || exit 1

	bzr pull --overwrite lp:~canonical-kernel-team/ubuntu-cve-tracker/kernel-team/ || exit 1
	bzr revert

	echo "*** merging upstream changes ..."
	bzr pull lp:ubuntu-cve-tracker || bzr merge lp:ubuntu-cve-tracker
	bzr commit -m 'update from upstream'

	echo "*** determine development release ..."
	# Work out what the development release is called here.
	devel=`
		PYTHONPATH="${PYTHONPATH:+$PYTHONPATH:}$(pwd)/scripts" python -c '
from cve_lib import devel_release
print devel_release
		'
	`
	echo "$devel"

	# Work out where linux-overlay is.
	echo "*** locate overlays ..."
	overlay="$out/$wip/active/10autotriage.linux"
	[ ! -f "$overlay" ] && overlay="$here/linux-overlay"
	echo "$overlay"

	# Get the list of cves we need to care about.
	(
		time="$SECONDS"

		echo "*** listing CVES ..."
		cves=(active/CVE-+([0-9])-+([0-9]))

		echo "*** enumerating cve commits ..."
		"$here/cves-commits" "${cves[@]}" >"$cve_list"

		echo "*** enumerating BUG commits ..."
		"$here/bugs-list" >>"$cve_list"

		let time="$SECONDS-$time"
		echo "*** listing CVES ... completed in ${time}s"
	) &
	# Prepare the git repos, update them, and cache things for launchpad.
	(
		mkdir -p "$out/state"
		"$here/cves-prepare" "$here/cves-autotriage.conf" "$out/state"
	) &

	# Allow the above to preceed in parallel, both needed for the below.
	wait

	echo "*** scanning git repositories ..."
	$here/cves-sync2 "$here/cves-autotriage.conf" "$out/state" "$overlay" "$cve_list" \
		> "$out/state/CVE-result-all"
	grep -v '^[0-9]' "$out/state/CVE-result-all" >"$out/state/CVE-result-cves"
	grep    '^[0-9]' "$out/state/CVE-result-all" >"$out/state/CVE-result-bugs"

	# Extract the list of CVE tracker cves.
	declare cves=(`< "$cve_list" awk '($1 !~ "^[0-9]") { print $1 }'`)

	rm -f "$cve_list"

	echo "*** applying primary updates ..."
	$here/cves-tracker-update "$devel" <"$out/state/CVE-result-cves"

	# echo "*** applying rebases ..."
	# $here/cves-rebase-transfer "$here/cves-autotriage.conf" "$devel" "${cves[@]}" | \
	#	$here/cves-tracker-update --rebase "$devel"

	echo "*** fixing -release pocket (and -updates for unsupported releases) ..."
	$here/cves-mark-pockets "$here/cves-autotriage.conf" "$out/state" "$devel" "${cves[@]}"

	echo "*** fixing ignored releases ..."
	$here/cves-mark-ignored "$here/cves-autotriage.conf" "$devel" "${cves[@]}"

	bzr commit -m 'autotriage'

	echo "*** generating notes ..."
	{
		$here/cves-notes-found-in "$here/cves-autotriage.conf" "$devel" \
			"$out/state/CVE-result-cves" &&
		$here/cves-notes-pockets "$here/cves-autotriage.conf" "$out/state" "$devel" "${cves[@]}"
	} >"$out/state/CVE-notes.new" && {
		if [ ! -f "$out/state/CVE-notes" ] || \
		   ! cmp -s "$out/state/CVE-notes.new" "$out/state/CVE-notes"; then     
			echo "notes updated"
			mv -f "$out/state/CVE-notes.new" "$out/state/CVE-notes"
		fi
	}
)

# All done with the cve tracker ... publish.
(
	cd "$out/$final" || exit 1

	echo "*** updating published version ..."
	if bzr diff --old "../$wip" >/dev/null 2>&1; then
		echo "NOTE: tree unchanged"
	else
		echo "NOTE: tree changed"
		bzr pull --overwrite "../$wip"
		bzr revert
	fi
)

# Finally generate bug updates.
(
	echo "*** generating pending bug list ..."
	"$here/cves-applied2" "$out/state/tagid.db" 'dump-bugs' >"$out/state/bugs-pending"
	awk '{print $1 " " $2 " " $4}' <"$out/state/bugs-pending" >"$HOME/public_html/status/bug-pending.new"
	mv -f "$HOME/public_html/status/bug-pending.new" "$HOME/public_html/status/bug-pending"

	echo "*** generating bug updates ..."
	{
		cat "$out/state/CVE-result-bugs"
		awk '{ print $1 " " $2 " " $3 " - released pending" }' <"$out/state/bugs-pending"
	} | \
	"$here/bugs-report" | \
	{
		echo "# BUG updates required as at `date`"
		echo "#I# updated-seconds `date +%s`"
		cat -
	} >"$HOME/public_html/status/bug-status-full.txt.new"
	egrep -v "^(#.#|$)" "$HOME/public_html/status/bug-status-full.txt.new" >"$HOME/public_html/status/bug-status.txt.new"

	mv -f "$HOME/public_html/status/bug-status-full.txt.new" "$HOME/public_html/status/bug-status-full.txt"
	mv -f "$HOME/public_html/status/bug-status.txt.new" "$HOME/public_html/status/bug-status.txt"
)

rm -f "$cve_list"

# Datestamp the log to aid debug.
let time="$SECONDS-$time"
echo "UPDATE: completed in $time"
date
