#!/usr/bin/python

# Copyright (C) 2009-2013  Canonical Ltd.
# Authors:
#   Andy Whitcroft <apw@canonical.com>
# Based on sru-report by:
#   Martin Pitt <martin.pitt@ubuntu.com>
#   Jean-Baptiste Lallement <jean-baptiste.lallement@canonical.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function

import logging
import os
import sys

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter

import apt_pkg

from ktl.kernel_versions import KernelVersions


pocket_data_cache = {}
def pocket_data(kv, series, source):
    if (kv, series, source) not in pocket_data_cache:
        pocket_data_cache[(kv, series, source)] = kv.pocket_data(series, source)
    return pocket_data_cache[(kv, series, source)]


def versions_payload(kv, ppa, out, args):
    (mode) = args[0]

    if mode == 'tags':
        (series, source) = args[1:3]
        pockets = pocket_data(kv, series, source)
        tags = pockets.all_viable()

        # If we have a newer tag in the CKT PPA treat it like a Proposed version
        if ppa:
            pockets = pocket_data(ppa, series, source)
            ppa_release = pockets.current_in_pocket('release', infer_release=True)
            if ppa_release and (len(tags) == 0 or apt_pkg.version_compare(tags[len(tags) - 1], ppa_release) < 0):
                tags.append(ppa_release)
        
        print("\n".join(tags), file=out)

    elif mode == 'release-updates':
        (series, source) = args[1:3]
        pockets = kv.pocket_data(series, source)
        release = pockets.current_in_pocket('release', infer_release=True)
        updates = pockets.current_in_pocket('updates')
        print(release, updates, file=out)

    elif mode == 'cve-pockets':
        (series, source) = args[1:3]
        pockets = pocket_data(kv, series, source)
        release = pockets.current_in_pocket('release', infer_release=True)
        security = pockets.current_in_pocket('security')
        updates = pockets.current_in_pocket('updates')
        proposed = pockets.current_in_pocket('proposed')

        ppa_release = None
        if ppa:
            pockets = pocket_data(ppa, series, source)
            ppa_release = pockets.current_in_pocket('release', infer_release=True)

        print(release, security, updates, proposed, ppa_release, file=out)

    elif mode in ('release', 'security', 'updates', 'proposed'):
        (series, source) = args[1:3]
        print(kv.current_in_pocket(mode, series, source), file=out)


def map_archive(archive):
    if archive == 'ubuntu':
        return KernelVersions(active_only=False)

    elif archive.startswith('ppa:'):
        bits = archive[4:].split('/')
        if len(bits) != 2 and (len(bits) != 3 or bits[1] != 'ubuntu'):
            return None

        return KernelVersions(ppa_owner=bits[0], ppa_name=bits[-1], active_only=False)


map_archive_cache_data = {}
def map_archive_cache(archive):
    if archive not in map_archive_cache_data:
        map_archive_cache_data[archive] = map_archive(archive)

    return map_archive_cache_data[archive]


def config_step(args, out=sys.stdout):
        (config, state, member, group) = args[1:5]
        member = int(member)
        group = int(group)

        with open(config, 'r') as cfd:
            count = -1
            for line in cfd:
                count += 1
                if (count % group) != member:
                    continue

                out.flush()

                a = line.split()
                (series, source, _, _, flags) = a[0:5]
                flags_match = ',' + flags + ','

                if series in ('upstream', 'product'):
                    continue
                if ',scan,' not in flags_match or ',git-tag:' in flags_match:
                    continue

                flags = flags.split(',')

                archives = [ 'ubuntu', 'ppa:canonical-kernel-team/ubuntu/ppa' ]
                for flag in flags:
                    if flag.startswith('archives:'):
                        archives = flag[9:].split('|')

                kv = map_archive_cache(archives[0])
                if not kv:
                    parser.error(archives[0] + ": invalid archive")
                
                ppa = None
                if len(archives) > 1:
                    ppa = map_archive_cache(archives[1])
                    if not ppa:
                        parser.error(archives[1] + ": invalid archive")

                series_file = series.replace('/', '@')
                series = series.split('/')[0]

                print("*** " + series + " " + source + " cve-pockets ...", file=out)
                pockets = os.path.join(state, series_file + '_' + source + '_cve-pockets')
                with open(pockets, 'w') as pfd:
                    versions_payload(kv, ppa, pfd, ['cve-pockets', series, source])
                print("*** " + series + " " + source + " tags ...", file=out)
                pockets = os.path.join(state, series_file + '_' + source + '_tags')
                with open(pockets, 'w') as tfd:
                    versions_payload(kv, ppa, tfd, ['tags', series, source])


if __name__ == "__main__":
    if os.getenv('DEBUG'):
        DEBUGLEVEL = logging.DEBUG
    else:
        DEBUGLEVEL = logging.WARNING

    logging.basicConfig(level=DEBUGLEVEL,
                        format="%(asctime)s - %(levelname)s - %(message)s")

    parser = ArgumentParser(description="package version lookup", formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--archive', action='append', help='Archive in which to look for the package')
    parser.add_argument('command', nargs='+', help='Command and arguments')
    args = parser.parse_args()

    if args.command and args.command[0] == 'cache-step':
        config_step(args.command)
        sys.exit(0)

    if not args.archive:
        parser.error("too few --archive parameters (one minimum)")
    if len(args.archive) > 2:
        parser.error("too many --archive parameters (two maximum)")

    kv = map_archive(args.archive[0])
    if not kv:
        parser.error(args.archive[0] + ": invalid archive")
    
    ppa = None
    if len(args.archive) > 1:
        ppa = map_archive(args.archive[1])
        if not ppa:
            parser.error(args.archive[1] + ": invalid archive")

    #kv = KernelVersions(active_only=False)
    #ppa = kv.ppa('canonical-kernel-team', 'ppa')
    #kv = KernelVersions(active_only=False)
    #kv = kv.ppa('snappy-dev', 'image')
    #kv = KernelVersions(ppa_owner='snappy-dev', ppa_name='image', active_only=False)
    #ppa = None

    versions_payload(kv, ppa, sys.stdout, args.command)
