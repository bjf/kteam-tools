#!/usr/bin/python

# Copyright (C) 2009-2013  Canonical Ltd.
# Authors:
#   Andy Whitcroft <apw@canonical.com>
# Based on sru-report by:
#   Martin Pitt <martin.pitt@ubuntu.com>
#   Jean-Baptiste Lallement <jean-baptiste.lallement@canonical.com>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function

import logging
import os
import sys

import apt_pkg

from ktl.kernel_versions import KernelVersions


pocket_data_cache = {}
def pocket_data(kv, series, source):
    if (kv, series, source) not in pocket_data_cache:
        pocket_data_cache[(kv, series, source)] = kv.pocket_data(series, source)
    return pocket_data_cache[(kv, series, source)]


def versions_payload(kv, ppa, out, args):
    (mode) = args[0]

    if mode == 'tags':
        (series, source) = args[1:3]
        pockets = pocket_data(kv, series, source)
        tags = pockets.all_viable()

        # If we have a newer tag in the CKT PPA treat it like a Proposed version
        pockets = pocket_data(ppa, series, source)
        ppa_release = pockets.current_in_pocket('release', infer_release=True)
        if ppa_release and (len(tags) == 0 or apt_pkg.version_compare(tags[len(tags) - 1], ppa_release) < 0):
            tags.append(ppa_release)
        
        print("\n".join(tags), file=out)

    elif mode == 'release-updates':
        (series, source) = args[1:3]
        pockets = kv.pocket_data(series, source)
        release = pockets.current_in_pocket('release', infer_release=True)
        updates = pockets.current_in_pocket('updates')
        print(release, updates, file=out)

    elif mode == 'cve-pockets':
        (series, source) = args[1:3]
        pockets = pocket_data(kv, series, source)
        release = pockets.current_in_pocket('release', infer_release=True)
        security = pockets.current_in_pocket('security')
        updates = pockets.current_in_pocket('updates')
        proposed = pockets.current_in_pocket('proposed')

        pockets = pocket_data(ppa, series, source)
        ppa_release = pockets.current_in_pocket('release', infer_release=True)

        print(release, security, updates, proposed, ppa_release, file=out)

    elif mode in ('release', 'security', 'updates', 'proposed'):
        (series, source) = args[1:3]
        print(kv.current_in_pocket(mode, series, source), file=out)

    elif mode == 'cache-step':
        (config, state, member, group) = args[1:5]
        member = int(member)
        group = int(group)

        with open(config, 'r') as cfd:
            count = -1
            for line in cfd:
                count += 1
                if (count % group) != member:
                    continue

                sys.stdout.flush()

                a = line.split()
                (series, source, _, _, flags) = a[0:5]
                flags = ',' + flags + ','

                if series in ('upstream', 'product'):
                    continue
                if ',scan,' not in flags or ',git-tag:' in flags:
                    continue

                print("*** " + series + " " + source + " cve-pockets ...", file=out)
                pockets = os.path.join(state, series + '-' + source + '_cve-pockets')
                with open(pockets, 'w') as pfd:
                    versions_payload(kv, ppa, pfd, ['cve-pockets', series, source])
                print("*** " + series + " " + source + " tags ...", file=out)
                pockets = os.path.join(state, series + '-' + source + '_tags')
                with open(pockets, 'w') as tfd:
                    versions_payload(kv, ppa, tfd, ['tags', series, source])


if __name__ == "__main__":
    if os.getenv('DEBUG'):
        DEBUGLEVEL = logging.DEBUG
    else:
        DEBUGLEVEL = logging.WARNING

    logging.basicConfig(level=DEBUGLEVEL,
                        format="%(asctime)s - %(levelname)s - %(message)s")

    kv = KernelVersions(active_only=False)
    ppa = kv.ppa('canonical-kernel-team', 'ppa')

    versions_payload(kv, ppa, sys.stdout, sys.argv[1:])
