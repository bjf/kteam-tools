#!/bin/bash

out="$HOME/public_html/status"
state="$out/dashboard-status"

mkdir -p "$state"

now=`date +%s`
date=`date '+%d-%b-%Y %H:%M'`

let later="$now+100"

status="$out/dashboard"

parse_reset()
{
	R_group='-'
	R_host='-'
	R_rhost='-'
	R_title='-'
	R_stamp='-'
	R_warning='-'
	R_alert='-'
	R_note='-'
	R_state='-'
	R_order='50'
}
parse_emit()
{
	# Handle basic multipliers -- add the iteration interval of the
	# dashboard itself.
	if [ "$R_warning" != '-' ]; then
		case "$R_warning" in
		*m)	let R_warning="${R_warning%m}*60" ;;
		*h)	let R_warning="${R_warning%h}*3600" ;;
		esac
		let R_warning="$R_warning+(5*60)"
	fi
	if [ "$R_alert" != '-' ]; then
		case "$R_alert" in
		*m)	let R_alert="${R_alert%m}*60" ;;
		*h)	let R_alert="${R_alert%h}*3600" ;;
		esac
		let R_alert="$R_alert+(5*60)"
	fi

	# Map direct state assigment.
	case "$R_state" in
	-)	;;
	G)	R_state="good" ;;
	W)	R_state="warn" ;;
	A)	R_state="alert" ;;
	*)	R_state="unknown" ;;
	esac

	# Apply time limits if the state is not yet known and we have a stamp.
	delta='-'
	if [ "$R_state" = '-' -a "$R_stamp" != '-' ]; then
		let delta="$now-$R_stamp"
		if [ "$delta" -gt "$R_alert" ]; then
			R_state="alert"
		elif [ "$delta" -gt "$R_warning" ]; then
			R_state="warn"
		else
			R_state="good"
		fi
	fi

	[ "$R_state" = '-' ] && R_state='unknown'

	# If we do not have a host, copy the rhost over.
	[ "$R_host" = '-' -a "$R_rhost" != '-' ] && R_host="$R_rhost"

	case "$R_group" in
	Dashboard)	gorder="00" ;;
	Host:*)		gorder="90" ;;
	*)		gorder="50" ;;
	esac

	echo "$gorder $R_group $R_order $R_title $R_host $delta $R_state $R_note"
}
parse_v1()
{
	parse_reset
	read R_group R_host R_title R_stamp R_warning R_alert R_note || return 1

	[ "$R_warning$R_alert" = '--' ] && R_state="$R_stamp"
	[ "$R_note" = '' ] && R_note='-'

	return 0
}
parse_v2()
{
	local ret

	parse_reset
	read -a R || return 1

	for param in "${R[@]}"
	do
		declare -g "R_$param"
	done

	return 0
}

{
	while read dhost url
	do
		wget -q -O "$state/$dhost.all" "$url"
		[ ! -f "$state/$dhost.all" ] && continue

		while read file
		do
			url=`dirname "$url"`"/$file"
			# Get this if we can ... ignore it, we will use the previous data.
			wget -q -O "$state/$file.new" "$url"

			if [ ! -f "$state/$file.new" ]; then
				echo "UNKNOWN 0 UNKNOWN MISSING%sDASHBOARD 0 unknown $url" >"$state/$file.new"
			fi
			mv "$state/$file.new" "$state/$file"
		done <"$state/$dhost.all"
	done <"$0.conf"

	echo "00 Dashboard 10 Scheduled%sUpdate `hostname` 0 good -"
	for file in "$state"/*.dash
	do
		# v1 Host:%sgloin gloin Update%sRepos 1425301160 90000 93600 
		# v2 V2 group=Host:%sgloin host=gloin title=Update%sChroots stamp=1425297795 warning=90000 alert=93600 

		# Assume that the first line is representative of all the enclosed entries.
		read version junk <"$file"
		case "$version" in
		V2)		parse="parse_v2" ;;
		V[0-9]*)	echo "Unknown version $version -- ignored"
				continue ;;
		*)		parse="parse_v1" ;;
		esac

		# Read and emit all of the lines.
		while $parse
		do
			parse_emit
		done <"$file"
	done
} | \
    sort | \
    tee "$status.txt.new"

#
# Generate the HTML tables from the .txt status summary.
#
n=0
last_section=''
while read gorder section order title host delta mode message
do
	let n="$n+1"

	if [ "$section" != "$last_section" ]; then
		let n="$n+3"
		last_section="$section"
	fi
done <"$status.txt.new"
# When we split we remove one blank line plus we suppress the one at the top.
let total="$n-2"
let halfway="($total/2)"

let min_distance="$total"
let min_where="0"

n=0
last_section=''
while read gorder section order title host delta mode message
do
	let n="$n+1"

	if [ "$section" != "$last_section" ]; then
		# Poor mans abs()
		let distance="$total-($n*2)"
		# abs(distance)
		distance="${distance#-}"

		#echo "DIFF: $section distance=$distance min_distance=$min_distance min_where=$min_where"
		if [ "$distance" -lt "$min_distance" ]; then
			min_distance="$distance"
			min_where="$n"
		fi
		[ "$last_section" != '' ] && let n="$n+1"
		let n="$n+2"
		last_section="$section"
	fi
done <"$status.txt.new"

let spacing="$total-(($min_where-1)*2)"
spacing2=0
if [ "$spacing" -lt 0 ]; then
	let spacing2="-$spacing"
	let spacing=0
fi
#echo "total=$total halfway=$halfway min_distance=$min_distance min_where=$min_where $(($total-$min_where)) spacing=$spacing spacing2=$spacing2"

cat - <<EOL >"$status.html.new"
<html>
<head>
<meta http-equiv="refresh" content="60">
<title>Kernel Dashboard</title>
<style>
.good { background-color: green; }
.warn { background-color: yellow; }
.alert { background-color: red; }
.unknown { background-color: orange; }
table.columns td.columns {
  vertical-align: top;
}
table.status {
  border: 0px;
  border-collapse: collapse;
}
table.status tr.gap, table.status tr.gap td {
  border: 0px;
  padding: 1px;
}
table.status tr, table.status th, table.status td {
  border: 1px solid black;
}
</style>
<script>
function pageLoaded() {
    if (!Date.now) {
	Date.now = function() { return new Date().getTime(); }
    }
    now = Math.floor(Date.now() / 1000)
    if ((now - $now) > (300 + 60 + 30)) {
	    document.getElementById("dashboard").style.background = "red";
    }
}
</script>
</head>
<body onload="pageLoaded()">
<h1>Kernel Dashboard ($date)</h1>
<table width=100% class="columns"><td class="columns" width=50%>
<table width=100% class="status">
EOL
last_section=''
n=0
while read gorder section order title host delta mode message
do
	let n="$n+1"
	if [ "$n" = "$min_where" ]; then
		echo "</table><td class=\"columns\" width=50%><table class=\"status\" width=100%>" >>"$status.html.new"
		last_section=''
		spacing="$spacing2"
	fi

	section=`echo "$section" | sed -e 's/%s/ /g' -e 's/%p/%/g' -e 's/^000-//'`
	title=`echo "$title" | sed -e 's/%s/ /g' -e 's/%p/%/g'`
	message=`echo "$message" | sed -e 's/%s/ /g' -e 's/%p/%/g'`
	[ "$message" = '-' ] && message=''
	
	if [ "$last_section" != "$section" ]; then
		if [ "$last_section" != '' ]; then
			echo "<tr class=\"gap\"><td >&nbsp;</tr>" >>"$status.html.new"
			let n="$n+1"
			if [ "$spacing" -gt 0 ]; then
				echo "<tr class=\"gap\"><td >&nbsp;</tr>" >>"$status.html.new"
				let spacing="$spacing-1"
			fi
		fi
		let n="$n+2"
		last_section="$section"

		echo "<tr><th colspan=4>$section</tr>" >>"$status.html.new"
		echo "<tr><th>Tool<th>Host<th>Last<th>Notes</tr>" >>"$status.html.new"
	fi

	# Ensure we do not execute something other than a number.
	#let time="$time + 0"
	#time=`date --date=@$time '+%d-%b-%Y %H:%M'`

	if [ "$delta" != '-' ]; then
		let delta="$delta / 60"
		ext='m'
		if [ "$delta" -ge 60 ]; then
			let delta="$delta / 60"
			ext='h'

			if [ "$delta" -ge "24" ]; then
				let delta="$delta / 24"
				ext='d'
			fi
		fi
		delta="$delta$ext"
	fi
	
	if [ "$section" = "Dashboard" ]; then
		id=" id=\"dashboard\""
	else
		id=''
	fi
	echo "<tr$id class=\"$mode\"><td>$title<td>$host<td>$delta<td>$message</tr>" >>"$status.html.new"
done <"$status.txt.new"

cat - <<EOL >>"$status.html.new"
</table>
</table>
</body>
</html>
EOL

mv -f "$status.html.new" "$status.html"
mv -f "$status.txt.new" "$status.txt"
