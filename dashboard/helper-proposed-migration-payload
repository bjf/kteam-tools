#!/usr/bin/python
from __future__ import print_function;

import os
import os.path
import sys
import yaml
import re
from datetime import datetime

re_extract_adt = re.compile(r'^autopkgtest for (\S+) (\S+):.*?(<a.*?>.*)')
re_extract_adt_result = re.compile(r'<a.*?>(.*?):\s*<span.*?>(.*?)</span>')
re_extract_force = re.compile(r'^Should wait for (\S+) (\S+) test, but forced')

now = datetime.now()
epoch = datetime.utcfromtimestamp(0)
now_ts = int((now - epoch).total_seconds())
host = os.uname()[1]

def encode(a):
    return str(a).replace('%', '%p').replace(' ', '%s')


def emit(record):
    row = 'V2'
    for key, value in record.items():
        row += " {0}={1}".format(key, encode(value))
    print(row)


def result(arg):
    if arg[3] in ('linux', 'linux-meta', 'linux-signed') or \
       arg[3].startswith('linux-lts-') or arg[3].startswith('linux-meta-lts-') or arg[3].startswith('linux-signed-lts-'):
        key1 = arg[3]
        key2 = arg[4]
        key3 = arg[0] + '_' + arg[1]
        if key1 not in results:
            results[key1] = {}
        if key2 not in results[key1]:
            results[key1][key2] = {}
        results[key1][key2][key3] = arg


for line in sys.stdin:
    (yfile, hfile, needed) = line.strip().split()
    needed_ts = int(needed)

    state = None
    if not os.path.exists(yfile):
        continue

    name = os.path.basename(yfile)
    if name.endswith('.migration'):
        name = name[0:-10]

    with open(yfile) as yfd:
        state = yaml.load(yfd)

    results = {}
    if os.path.exists(hfile):
        with open(hfile) as hfd:
            for line in hfd:
                arg = line.strip().split()

                result(arg)

    title = name + ': Migration'

    run = state['generated-date']
    run_ts = int((run - epoch).total_seconds())

    tests_running = 'idle'
    for source in state['sources']:
        if 'cruft-arch' in source['reason']:
            result([source['source'], source['new-version'], 'NBS', source['source'], source['new-version']])


        forced_reasons = []
        if 'forced-reason' in source:
            for reason_str in source['forced-reason']:
                forced_reasons.append(reason_str.split())

        if 'tests' in source:
            if 'autopkgtest' in source['tests']:
                for test_ver in source['tests']['autopkgtest']:
                    test_result = source['tests']['autopkgtest'][test_ver]
                    (test, tversion) = test_ver.split()

                    tstate = 'PASS'
                    state_order = ('PASS', 'ALWAYSFAIL', 'RUNNING', 'REGRESSION')

                    for arch in test_result:
                        state = test_result[arch][0]
                        if state == 'RUNNING':
                            needed_ts = run_ts
                            tests_running = 'running'
                        if state_order.index(state) > state_order.index(tstate):
                            tstate = state

                for reason_arg in forced_reasons:
                    if reason_arg[0] == 'skiptest' or \
                       reason_arg[0] == 'badtest' and reason_arg[1] == test and reason_arg[2] == tversion:
                        if tstate in ('ALWAYSFAIL', 'RUNNING', 'REGRESSION'):
                            tstate = 'IGNORED'
                result([test, tversion, tstate, source['source'], source['new-version']])


    for key1 in sorted(results.keys()):
        keyl = sorted(results[key1].keys(), reverse=True)
        if len(keyl) > 0:
            key2 = keyl[0]
            for key3 in results[key1][key2]:
                arg = results[key1][key2][key3]

                if arg[2] in ('REGRESSION', 'NBS'):
                    tstate = 'W'
                else:
                    tstate = 'G'

                emit({
                    'group':    'Proposed Migration',
                    'host':     host,
                    'title':    name + ': ' + arg[3] + '_' + arg[4] + ' test ' + arg[0] + '_' + arg[1],
                    'state':    tstate,
                    'note':     arg[2],
                })

    # If the run completed since it was triggered, all is good, else give it an 
    # hour to get there, after that warn for a further hour, then alert.
    if run_ts > needed_ts:
        tstate = "G"
    elif (now_ts - needed_ts) < (125*60):
        tstate = "G"
    elif (now_ts - needed_ts) < (185*60):
        tstate = "W"
    else:
        tstate = "A"

    needed = datetime.fromtimestamp(needed_ts)

    needed_str = str(now - needed).split('.')[0]
    run_str = str(now - run).split('.')[0]
    emit({
        'group':    'Proposed Migration',
        'host':     host,
        'title':    title,
        'state':    tstate,
        'note':     'needed={0} run={1} tests={2}'.format(needed_str, run_str, tests_running),
        'order':    40,
    })

emit({
    'group':    'Proposed Migration',
    'host':     host,
    'title':    'Update Watcher',
    'stamp':    now_ts,
    'warning':  1200,
    'alert':    1800,
    'order':    10,
})
