#!/usr/bin/python
from __future__ import print_function;

import os
import os.path
import sys
import yaml
import re
from datetime import datetime

re_extract = re.compile(r'^autopkgtest for (\S+) (\S+):.*?<span .*?>(.*?)</span>')

now = datetime.now()
epoch = datetime.utcfromtimestamp(0)
now_ts = int((now - epoch).total_seconds())
host = os.uname()[1]

def encode(a):
    return str(a).replace('%', '%p').replace(' ', '%s')


def emit(record):
    row = 'V2'
    for key, value in record.items():
        row += " {0}={1}".format(key, encode(value))
    print(row)


for line in sys.stdin:
    (yfile, hfile, needed) = line.strip().split()
    needed_ts = int(needed)

    state = None
    if not os.path.exists(yfile):
        continue

    name = os.path.basename(yfile)
    if name.endswith('.migration'):
        name = name[0:-10]

    with open(yfile) as yfd:
        state = yaml.load(yfd)

    results = {}
    if os.path.exists(hfile):
        with open(hfile) as hfd:
            for line in hfd:
                arg = line.strip().split()

                if arg[3].startswith('linux'):
                    key = arg[3] + '-' + arg[4]
                    key2 = arg[0] + '-' + arg[1]
                    if key not in results:
                        results[key] = {}
                    results[key][key2] = arg

    title = name + ': Migration'

    run = state['generated-date']
    run_ts = int((run - epoch).total_seconds())

    tests_running = False
    for source in state['sources']:
        for excuse in source['excuses']:
            if excuse.startswith('autopkgtest'):
                if 'Test in progress' in excuse:
                    needed_ts = run_ts
                    tests_running = True
                if source['source'].startswith('linux'):
                    match = re_extract.match(excuse)
                    if match:
                        (test, tversion, state) = (match.group(1), match.group(2), match.group(3))

                        if state == 'Pass':
                            tstate = 'PASS'
                        elif state ==  'Regression':
                            tstate = 'FAIL'
                        else:
                            tstate = 'RUNNING'

                        key = source['source'] + '-' + source['new-version']
                        key2 = test + '-' + tversion
                        if key not in results:
                            results[key] = []
                        results[key][key2] = [test, tversion, tstate, source['source'], source['new-version']]

    if tests_running:
        title += ' Tests Running'

    keyl = sorted(results.keys(), reverse=True)
    if len(keyl) > 0:
        key = keyl[0]
        for key2 in results[key]:
            arg = results[key][key2]

            if arg[2] == 'FAIL':
                tstate = 'A'
            else:
                tstate = 'G'

            emit({
                'group':    'Proposed Migration',
                'host':     host,
                'title':    name + ': Test ' + arg[0] + '-' + arg[1] + ' for ' + arg[3] + '-' + arg[4],
                'state':    tstate,
                'note':     arg[2],
            })

    # If the run completed since it was triggered, all is good, else give it 35
    # minutes to get there, after that warn for a further hour, then alert.
    if run_ts > needed_ts:
        tstate = "G"
    elif (now_ts - needed_ts) < 2100:
        tstate = "G"
    elif (now_ts - needed_ts) < 5700:
        tstate = "W"
    else:
        tstate = "A"

    needed = datetime.fromtimestamp(needed_ts)

    needed_str = str(now - needed).split('.')[0]
    run_str = str(now - run).split('.')[0]
    emit({
        'group':    'Proposed Migration',
        'host':     host,
        'title':    title,
        'state':    tstate,
        'note':     'needed={0} run={1}'.format(needed_str, run_str),
    })

emit({
    'group':    'Proposed Migration',
    'host':     host,
    'title':    'Update Watcher',
    'stamp':    now_ts,
    'warning':  1200,
    'alert':    1800,
    'order':    10,
})
