#!/usr/bin/python
from __future__ import print_function

import sys
import os
import yaml
import json


class AdtMatrixSeed(object):
    def __init__(self, cache):
        self.cache_file = cache
        self.cache = {}
        self.latest = {}
        self.nbs = {}

        self.britney_cache = {}

        if os.path.exists(cache):
            with open(cache) as cachef:
                tmp = json.load(cachef)

            if 'cache' in tmp:
                self.cache = tmp['cache']
            if 'cache-latest' in tmp:
                self.latest = tmp['cache-latest']


    def save(self):
        with open(self.cache_file + '.new', 'w') as cfd:

            # seeds: make a list based output for adt-matrix.
            seeds = {}
            for seriespkg in self.cache:
                seeds[seriespkg] = []
                for pkg in sorted(self.cache[seriespkg]):
                    tmp_arch = []
                    for arch in sorted(self.cache[seriespkg][pkg]):
                        tmp_arch.append(arch)
                    seeds[seriespkg].append((pkg, tmp_arch))
                        
            # seeds: make a list based output for adt-matrix.
            latest_merged = {}
            for master in self.latest:
                latest_merged[master] = {}
                for member in self.latest[master]:
                    for key in self.latest[master][member]:
                        tmp = latest_merged[master].setdefault(key, [])
                        new = list(set(tmp + self.latest[master][member][key].keys()))
                        latest_merged[master][key] = new

            out = {
                'cache':            self.cache,
                'cache-latest':     self.latest,
                'seeds':            seeds,
                'seeds-latest':     latest_merged,
            }
            json.dump(out, cfd, indent=2)
        os.rename(self.cache_file + '.new', self.cache_file)


    def britney_hierachy(self, state, record, seen=None):    
        if seen == None:
            seen = {}
        if record['source'] in seen:
            return []
        seen[record['source']] = True

        hier = [ record ]

        if 'excuses' in record:
            for line in record['excuses']:
                if line.startswith('Depends:'):
                    bits = line.strip().split()
                    for record2 in state['sources']:
                        if record2['source'] == bits[2]:
                            hier += self.britney_hierachy(state, record2, seen)

        return hier


    def britney_load(self, series, britney):
        if series not in self.britney_cache:
            with open(britney) as britneyf:
                self.britney_cache[series] = yaml.load(britneyf)

        return self.britney_cache[series]


    def britney_nbs(self, series, flags):
        if series in self.nbs:
            return
        self.nbs[series] = True

        print('#\n# ' + series + '\n#')
        for record in self.britney_cache[series]['sources']:
            if 'excuses' in record:
                pkgs = {}
                for excuse in record['excuses']:
                    if excuse.startswith('old binaries left on'):
                        (prefix, remainder) = excuse.split('>:', 1)
                        for version_group in remainder.split(';'):
                            (package_string, version) = version_group.split('(', 1)
                            for package in package_string.split(', '):
                                pkgs[package.strip()] = True

                if len(pkgs) > 0:
                    print('remove-package -m NBS -d ubuntu -s {}-proposed -b -y {} # {}'.format(series, " ".join(pkgs.keys()), record['source']))


    def accumulate(self, series, package, flags, britney):
        state = self.britney_load(series, britney)

        if 'devel' not in flags:
            self.britney_nbs(series, flags)

        for record in state['sources']:
            if record['source'] != package:
                continue;

            # The persistant list holds any package we ever tested against.
            pcache = self.cache.setdefault(series + '-' + package, {})
            # The current lists holds those we tested on in the most recent test run.
            lcache = self.latest.setdefault(series + '-' + package, {})

            debug = [ record['source'] ]
            for record2 in self.britney_hierachy(state, record):
                if record2['source'] not in debug:
                    debug.append(record2['source'])
                if 'tests' in record2 and 'autopkgtest' in record2['tests']:
                    # If we have a list, this becomes the new list.
                    tcache = lcache[record2['source']] = {}
                    for pkg in record2['tests']['autopkgtest']:
                        for arch in record2['tests']['autopkgtest'][pkg]:
                            (package, version) = pkg.split()
                            pcache.setdefault(package, {})[arch] = True
                            tcache.setdefault(package, {})[arch] = True

            print('hierachy ' + series + ' ' + ' '.join(debug), file=sys.stderr)


matrix_seed = AdtMatrixSeed('package-relation.json')
for line in sys.stdin:
    (series, package, parent, flags, britney) = line.strip().split()
    matrix_seed.accumulate(series, package, flags.split(','), britney)
matrix_seed.save()
