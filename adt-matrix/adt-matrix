#!/usr/bin/python
from __future__ import print_function

# -*- coding: utf-8 -*-

# Copyright (C) 2013-2015 Canonical Ltd.
# Authors:
#   Andy Whitcroft <apw@ubuntu.com>
# Based in part on autopkgtest.py by:
#   Colin Watson <cjwatson@ubuntu.com>
#   Jean-Baptiste Lallement <jean-baptiste.lallement@canonical.com>
#   Martin Pitt <martin.pitt@ubuntu.com>

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

import os
import sys
import time
import json
import tarfile
import io
import copy
import itertools
import re
import apt_pkg
#from urllib.parse import urlencode
#from urllib.request import urlopen
from urllib import urlencode
from urllib2 import urlopen
from functools import cmp_to_key
from datetime import datetime
def srchash(src):
    '''archive hash prefix for source package'''

    if src.startswith('lib'):
        return src[:4]
    else:
        return src[0]


def pkg_link(pkg, series):
    return "http://autopkgtest.ubuntu.com/packages/{0}/{1}/".format(srchash(pkg), pkg)


def pkg_arch_link(pkg, series, arch):
    return "http://autopkgtest.ubuntu.com/packages/{0}/{1}/{2}/{3}/".format(srchash(pkg), pkg, series, arch)


class AutoPackageTest(object):
    """autopkgtest integration

    Look for autopkgtest jobs to run for each update that is otherwise a
    valid candidate, and collect the results.  If an update causes any
    autopkgtest jobs to be run, then they must all pass before the update is
    accepted.
    """

    def __init__(self, series = None, source = None, packages = [], version_low = None, version_high = None, flavour = None, stamp = None):
        self.cache = {}
        self.dirty = False

        self.series = series
        self.source = source
        self.packages = packages
        self.version_low = version_low
        self.version_high = version_high
        self.flavour = flavour
        self.stamp = stamp

        self.seen = {}
        self.results = {}
        self.latest = {}

        self.cache_file = self.series + ".cache"

        if os.path.exists(self.cache_file):
            with open(self.cache_file) as cfd:
                tmp = json.load(cfd)
                self.seen = tmp['seen']
                self.results = tmp['results']
                self.latest = tmp['latest']

            self.log_verbose('Read previous results from {}'.format(self.cache_file))
        else:
            self.log_verbose('Read previous results from {} -- initialising'.format(self.cache_file))


    def log_error(self, msg):
        print('E: [%s] - %s' % (time.asctime(), msg))


    def log_verbose(self, msg):
        print('I: [%s] - %s' % (time.asctime(), msg))


    #
    # AMQP/cloud interface helpers
    #
    def fetch_swift_results(self, swift_url, src, arch, trigger=None):
        '''Download new results for source package/arch from swift'''

        src_arch_key = src + ' ' + arch

        # prepare query: get all runs with a timestamp later than latest_stamp
        # for this package/arch; '@' is at the end of each run timestamp, to
        # mark the end of a test run directory path
        # example: <autopkgtest-wily>wily/amd64/libp/libpng/20150630_054517@/result.tar
        query = {'delimiter': '@',
                 'prefix': '%s/%s/%s/%s/' % (self.series, arch, srchash(src), src)}
        try:
            query['marker'] = query['prefix'] + self.seen[src_arch_key]
        except KeyError:
            # no stamp yet, download all results
            pass

        # request new results from swift
        url = os.path.join(swift_url, 'autopkgtest-' + self.series)
        url += '?' + urlencode(query)
        try:
            f = urlopen(url)
            if f.getcode() == 200:
                result_paths = f.read().decode().strip().splitlines()
            elif f.getcode() == 204:  # No content
                result_paths = []
            else:
                self.log_error('Failure to fetch swift results from %s: %u' %
                               (url, f.getcode()))
                f.close()
                return
            f.close()
        except IOError as e:
            self.log_error('Failure to fetch swift results from %s: %s' % (url, str(e)))
            return

        for p in result_paths:
            self.fetch_one_result(
                os.path.join(swift_url, 'autopkgtest-' + self.series, p, 'result.tar'),
                src, arch, trigger)
            self.dirty = True


    def version_valid(self, version):
        if not version:
            return False
        (ver, flavour) = version.split()
        if self.flavour and self.flavour != flavour:
            return False
        if self.version_low and apt_pkg.version_compare(ver, self.version_low) < 0:
            return False
        if self.version_high and apt_pkg.version_compare(ver, self.version_high) >= 0:
            return False
        return True


    def version_list(self):
        verlist = []
        for version in sorted(self.results.keys(), key=cmp_to_key(apt_pkg.version_compare)):
            if self.version_valid(version):
                verlist.append(version)

        return verlist


    fetch_one_kernel_pat = re.compile(r'^(linux-image-[0-9\.]+-[0-9]+-(\S+))\s+(\S+)')
    # Linux 4.2.0-10-generic #11-Ubuntu SMP Sun Sep 13 11:23:03 UTC 2015"
    testinfo_kernel_version_pat = re.compile(r'^Linux\s+(\S+?-\S+?)-(\S+)\s#(\S+)-Ubuntu')
    def fetch_one_result(self, url, src, arch, trigger=None):
        '''Download one result URL for source/arch

        Remove matching pending_tests entries. If trigger is given (src, ver)
        it is added to the triggers of that result.
        '''

        src_arch_key = src + ' ' + arch

        try:
            f = urlopen(url)
            if f.getcode() == 200:
                tar_bytes = io.BytesIO(f.read())
                f.close()
            else:
                self.log_error('Failure to fetch %s: %u' % (url, f.getcode()))
                return
        except IOError as e:
            self.log_error('Failure to fetch %s: %s' % (url, str(e)))
            return

        (kernel_pkg, kernel_ver) = (None, None)
        testinfo = None
        try:
            with tarfile.open(None, 'r', tar_bytes) as tar:
                exitcode = int(tar.extractfile('exitcode').read().strip())
                srcver = tar.extractfile('testpkg-version').read().decode().strip()
                (ressrc, ver) = srcver.split()
                # Accumulate the latest versions of packages seen so we can detect missing results.
                if ressrc not in self.latest or apt_pkg.version_compare(self.latest[ressrc], ver) < 0:
                    self.latest[ressrc] = ver
                if ressrc == self.source:
                    (kernel_pkg, kernel_ver) = (ressrc, ver + ' ' + self.flavour)
                else:
                    for line in tar.extractfile('testbed-packages'):
                        match = self.fetch_one_kernel_pat.match(line.decode().strip())
                        if match:
                            if not kernel_ver or apt_pkg.version_compare(match.group(3), kernel_ver) >= 0:
                                if match.group(2) != '-virtual':
                                    (kernel_pkg, kernel_ver) = (match.group(1), match.group(3) + ' ' + match.group(2))
                try:
                    testinfo = json.load(tar.extractfile('testinfo.json'))
                except (KeyError, ValueError, tarfile.TarError) as e:
                    pass
        except (KeyError, ValueError, tarfile.TarError) as e:
            self.log_error('%s is damaged: %s' % (url, str(e)))
            # we can't just ignore this, as it would leave an orphaned request
            # in pending.txt; consider it tmpfail
            exitcode = 16
            ressrc = src
            ver = None

        # If we have testinfo then we may have a real kernel version.
        if testinfo and 'virt_server' in testinfo and testinfo['virt_server'].startswith('adt-virt-ssh'):
            if 'kernel_version' in testinfo:
                match = self.testinfo_kernel_version_pat.match(testinfo['kernel_version'])
                if match:
                    (kernel_pkg, kernel_ver) = ('linux', match.group(1) + '.' + match.group(3) + ' ' + match.group(2))

        if src != ressrc:
            self.log_error('%s is a result for package %s, but expected package %s' %
                           (url, ressrc, src))
            return

        stamp = os.path.basename(os.path.dirname(url))
        # allow some skipped tests, but nothing else
        passed = exitcode in [0, 2]

        self.log_verbose('Fetched test result for %s/%s/%s %s: %s (kernel %s %s)' % (
            src, ver, arch, stamp, passed and 'pass' or 'fail', kernel_pkg, kernel_ver))

        # add this result
        if kernel_pkg and kernel_ver:
            results = self.results.setdefault(kernel_ver, {}).setdefault(src, {})
            results[arch] = (passed, ver, os.path.dirname(url) + '/')

        # update latest_stamp
        if src_arch_key not in self.seen or stamp > self.seen[src_arch_key]:
            self.seen[src_arch_key] = stamp


    def update(self):
        for pkgarchs in self.packages:
            (pkg, archs) = pkgarchs
            for arch in archs:
                adt.fetch_swift_results('https://objectstorage.prodstack4-5.canonical.com/v1/AUTH_77e2ada1e7a84929a74ba3b87153c0ac/', pkg, arch)


    def save(self):
        if self.dirty:
            tmp = { 'seen': self.seen, 'results': self.results, 'latest': self.latest }
            with open(self.cache_file + '.new', 'w') as cfd:
                json.dump(tmp, cfd, indent=2)
            os.rename(self.cache_file + '.new', self.cache_file)
            self.log_verbose('Saved results to {}'.format(self.cache_file))
            dirty = False


    def results_data(self):
        result = {}
        verlist = self.version_list()
        for pkgarchs in self.packages:
            (pkg, archs) = pkgarchs
            good_ever = {}
            some_ever = {}
            for arch in archs:
                for ver in verlist:
                    (status, rurl) = (None, None)
                    if pkg in self.results[ver] and arch in self.results[ver][pkg]:
                        (tstatus, version, rurl) = self.results[ver][pkg][arch]
                        some_ever[arch] = True
                        if ver == verlist[-1] and version != self.latest[pkg]:
                            status = 'MISS'
                        elif tstatus:
                            good_ever[arch] = True
                            status = 'GOOD'
                        elif arch in good_ever:
                            status = 'REGR'
                        else:
                            status = 'FAIL'
                    elif arch in some_ever:
                        status = 'MISS'

                    if status:
                        tmp = result.setdefault(ver, {})
                        tmp = tmp.setdefault(pkg, {})
                        tmp[arch] = (status, rurl)


        status = { 'REGR': 0, 'FAIL': 0, 'GOOD': 0, 'MISS': 0 }
        ver = None
        if len(verlist) > 0:
            ver = verlist[-1]
            for pkgarchs in self.packages:
                (pkg, archs) = pkgarchs
                for arch in archs:
                    if ver in result and pkg in result[ver] and arch in result[ver][pkg]:
                        status[result[ver][pkg][arch][0]] += 1
        
        count = 0
        total = 0
        summary = []
        for state in [ 'REGR', 'FAIL', 'GOOD', 'MISS', None ]:
            if state and status[state] > 0:
                summary.append(state + ": " + str(status[state]))
                if state != 'MISS':
                    count += status[state]
                total += status[state]

        #summary.append("Total: " + str(counts.get(ver, 0)) + '/' + str(len(self.packages)))

        summary_str = ' '.join(summary)

        if ver:
            (version, flavour) = ver.split()
        else:
            version = None

        ### counts are in <jobs>/<packages> which really do not make sense
        return ((summary_str[0:4], summary_str, version, count, total), result)


    def matrix(self):
        title = self.source + " on " + self.series
        (info, results) = self.results_data()

        page = """<html>
<head>
<title>ADT Test Matrix -- {0}</title>
<style>
.GOOD {{ background-color: green; }}
.RUN {{ background-color: yellow; }}
.MISS {{ background-color: yellow; }}
.FAIL {{ background-color: orange; }}
.REGR {{ background-color: red; }}
table.matrix {{
    border-collapse: collapse;
}}
table.matrix, table.matrix th, table.matrix td {{
   border: 1px solid black;
}} 
</style>
</head>
<body>
<h1>ADT Test Matrix for {0} ({1})</h1>
<table class="matrix">
""".format(title, self.stamp)

        verlist = sorted(results.keys(), key=cmp_to_key(apt_pkg.version_compare))    

        # Title ...
        page += '<tr><th rowspan="2" colspan="2"><th colspan="{0}">{1}<th rowspan="2" colspan="2"></tr>\n'.format(len(verlist), title)

        # Versions ...
        page += '<tr>'
        for verflav in verlist:
            (version, flavour) = verflav.split()
            page += '<th>' + version
        page += '</tr>\n'

        # Data ...
        for pkgarchs in self.packages:
            (pkg, archs) = pkgarchs
            archs_seen = {}
            for arch in archs:
                for ver in verlist:
                    if pkg in results[ver] and arch in results[ver][pkg]:
                        archs_seen[arch] = True

            archs_good = []
            for arch in archs:
                if arch in archs_seen:
                    archs_good.append(arch)

            for arch in archs_good:
                arch_link = pkg_arch_link(pkg, self.series, arch)

                page += '<tr>'
                if arch == archs_good[0]:
                    page += '<th rowspan="{2}"><a href="{1}">{0}</a>'.format(pkg, pkg_link(pkg, self.series), len(archs_good))
                page += '<td><a href={1}>{0}</a>'.format(arch, arch_link)
                for ver in verlist:
                    if pkg in results[ver] and arch in results[ver][pkg]:
                        (status, status_link) = results[ver][pkg][arch]
                        if status_link:
                            status_link += 'log.gz'
                            fmt = '<td class="{0}"><a href="{2}">{1}</a>'
                        else:
                            fmt = '<td class="{0}">{1}'
                        page += fmt.format(status, status, status_link)
                    else:
                        page += '<td>&nbsp;'
                page += '<td><a href={1}>{0}</a>'.format(arch, arch_link)
                if arch == archs_good[0]:
                    page += '<th rowspan="{2}"><a href="{1}">{0}</a>'.format(pkg, pkg_link(pkg, self.series), len(archs_good))
                page += '</tr>\n'

        page += """</table>
</body>
</html>
"""
        return (info, page)


apt_pkg.init_system()

with open("package-relation.json") as seedf:
    package_seed = json.load(seedf)

stamp = datetime.now().replace(microsecond=0)

index = "index.html"
with open(index + ".new", "w") as indexf:
    print("""\
<html>
<head>
<title>ADT Test Matrix</title>
<style>
.MIGRATED {{ background-color: darkgray; }}
.PASS {{ background-color: green; }}
.BUILDING {{ background-color: yellow; }}
.RUNNING {{ background-color: yellow; }}
.MISSING {{ background-color: yellow; }}
.FAIL {{ background-color: yellow; }}
.ALWAYSFAIL {{ background-color: yellow; }}
.REGRESSION {{ background-color: red; }}
table.matrix {{
    border-collapse: collapse;
}}
#table.matrix, table.matrix th, table.matrix td {{
#   border: 1px solid black;
#}} 
table.matrix th {{
    text-align: left;
}}
table.matrix td {{
    padding: 5px;
}}
#.row:nth-child(6n+1) {{ background-color: darkgrey }}
#.row:nth-child(6n+2) {{ background-color: darkgrey }}
#.row:nth-child(6n+3) {{ background-color: darkgrey }}
.row:nth-child(even) {{ background-color: lightgrey }}
.pointer {{ cursor: pointer; }}
</style>
</head>
<body>
<h1>ADT Test Matrix ({0})</h1>
<table class="matrix">
<tr class="row"><th>Series<th>Package<th>Latest Version<th>Counts&nbsp;<th>Status<th>Migration Status</tr>
""".format(stamp), file=indexf)
    
    updated = {}

    series_prev = None
    for line in sys.stdin:
        bits = line.split()
        migrated = False
        for i in range(0, len(bits)):
            if bits[i] == '-':
                bits[i] = None
        (series, package, flavour, ver_low, ver_high, migration) = bits

        key = series + "-" + package
        if key in package_seed:
            seed = package_seed[key]
        else:
            seed = []

        seen = False
        for pkgarchs in seed:
            (pkg, archs) = pkgarchs
            if package == pkg:
                seen = True
        if not seen:
            seed.append((package, ['amd64', 'i386', 'ppc64el', 'armhf']))

        adt = AutoPackageTest(
                stamp = stamp,
                series = series,
                source = package,
                packages = seed,
                flavour = flavour,
                version_low = ver_low,
                version_high = ver_high,
            )

        if series not in updated:
            adt.update()
            adt.save()
            updated[series] = True

        (info, matrix) = adt.matrix()
        (state, summary, version, count, total) = info

        html = series + '-' + package + '.html'
        with open(html + '.new', 'w') as mfd:
            print(matrix, end=None, file=mfd)

            os.rename(html + '.new', html)

        mig_pkg = package.replace('linux', 'linux-meta')
        mig_url = "http://people.canonical.com/~ubuntu-archive/proposed-migration/" + series + "/update_excuses.html#" + mig_pkg
        print('<tr class="row"><td>{0}<td>{1}<td>{3}<td>{6}/{7}<td><a href="{2}">{4}</a><td class="{8}"><a href="{9}">{8}</a></tr>\n'.format(series, package, html, version, summary, state, count, total, migration, mig_url), file=indexf)

    print("""\
</table>
</body>
</html>
""", file=indexf)

os.rename(index + ".new", index)
