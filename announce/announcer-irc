#!/usr/bin/python3

import json
import logging
import os
import time
import requests
import socket
import ssl
import threading
import queue

from argparse import ArgumentParser
from string import punctuation

from ktl.log import cdebug, cinfo, center, cleave
from ktl.msgq import MsgQueueService, MsgQueueCredentials

from secrets import Secrets


class ClientCommand(object):
    """
    A command to the client thread. Each command type has its associated
    data:

    QUIT:       exception
    MSGQ_RAW:   full payload
    MM_RAW:     mattermost event structures
    """
    QUIT, MSGQ_RAW, IRC_RAW = range(3)

    def __init__(s, type, data=None):
        s.type = type
        s.data = data


class IrcEvents(threading.Thread):
    # __init__
    #
    def __init__(s, cfg={}, cmd_q=queue.Queue()):
        super().__init__()

        s.daemon = True

        s.cmd_q = cmd_q
        s.alive = threading.Event()
        s.alive.set()
        s.socket = None

        s.cfg = cfg

        cfg['channels'] = cfg['channels'].split()

        s.irc_register = [
            'PASS ' + s.cfg['password'] + '\r\n',
            'NICK ' + s.cfg['nick'] + '\r\n',
            'USER %s 0 * :%s\r\n' % (s.cfg['user'], s.cfg['name']),
        ]
        s.irc_joins = [ 'JOIN ' + channel + '\r\n' for channel in s.cfg['channels'] ]

    # _connect
    #
    def _connect(s, host, port, use_ssl):
        center('IrcClient::_connect')
        s.raw_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.raw_socket.connect((host, port))
        s.socket = ssl.wrap_socket(s.raw_socket)
        #s.client_socket.settimeout(15)
        cleave('IrcClient::_connect')

    # irc_decode
    #
    def irc_decode(s, line):
        who = 'UNKNOWN'
        if line[0] == ':':
            (who, line) = line.split(' ', 1)
            who = who[1:].split('!')[0]

        bits = line.split(' :')
        cmd = bits[0].split(' ')
        if len(bits) > 1:
            cmd.append(bits[1])

        return who, cmd

    # on_ping
    #
    def on_ping(s, line):
        center('IrcClient::on_ping')

        sent = s.raw_send('PONG %s\r\n' % (line.replace('PING :', '')))
        cdebug('sending PONG')
        s.sent_pong = True

        cleave('IrcClient::on_ping')

    # on_join
    #
    def on_join(s, line):
        center('IrcClient::on_join')

        (who, cmd) = s.irc_decode(line)

        cdebug('line: "%s"' % line)
        cdebug('who: "%s"' % who)
        cdebug('cmd: "%s"' % str(cmd))

        if who == s.cfg['nick']:
            cdebug('I just joined')
            sent = s.raw_send('PRIVMSG %s :%s\r\n' % (cmd[1], '\o/'))
        else:
            cdebug('%s just joined' % who)

        cleave('IrcClient::on_join')

    # privmsg_parse
    #
    def privmsg_parse(s, line):
        center('IrcClient::privmsg_parse')

        cmd  = None
        chan = None
        msg  = None
        who  = None
        me   = False

        s1 = line.split(':', 2)
        cdebug('s1: %s' % str(s1))

        # If it's not for me, ignore it
        #
        s2 = s1[1].split(' ')
        if s1[2].startswith(s.cfg['nick']) or s2[2] == s.cfg['nick']:
            cdebug('s2: %s' % str(s2))
            cdebug('line: "%s"' % line)

            cmd  = s2[1]
            chan = s2[2]
            msg  = s1[2].replace(s.cfg['nick'], '', 1).strip(punctuation + ' ')

            who = line.split('!')[0].replace(':', '')
            cdebug('     cmd: %s' % cmd)
            cdebug('    chan: %s' % chan)
            cdebug('     msg: "%s"' % msg)
            cdebug('     who: %s' % who)

            me = True

        cdebug(' ')

        cleave('IrcClient::privmsg_parse')
        return [me, cmd, chan, msg, who]

    # on_privmsg
    #
    def on_privmsg(s, line):
        center('IrcClient::on_privmsg')

        cinfo("INCOMING PRIVMSG" + line)
        (forme, cmd, chan, msg, who) = s.privmsg_parse(line)

        cdebug('      me: %s' % forme)
        cdebug('     cmd: %s' % cmd)
        cdebug('    chan: %s' % chan)
        cdebug('     msg: "%s"' % msg)
        cdebug('     who: %s' % who)

        if forme:
            s.cmd_q.put(ClientCommand(ClientCommand.IRC_RAW, {'from': who, 'channel': chan, 'message': msg}))

        cleave('IrcClient::on_privmsg')

    def raw_send(s, data):
        return s.socket.send(data.encode())

    # privmsg
    #
    def privmsg(s, chan, msg):
        sent = s.raw_send('PRIVMSG %s :%s\r\n' % (chan, msg))

    # send_registration
    #
    def send_registration(s):
        cdebug('Registration Start')
        for cmd in s.irc_register:
            cdebug('send_registration: ' + cmd.split(' ')[0])
            sent = s.raw_send(cmd)
            cdebug('send_registration: ' + cmd + " = " + str(sent))


    # send_join
    #
    def send_join(s):
        if len(s.irc_joins) > 0:
            cmd = s.irc_joins.pop(0)
            cdebug('send_join: ' + cmd.strip())
            sent = s.raw_send(cmd)

    # run
    #
    def run(s):
        s._connect(s.cfg['host'], s.cfg['port'], s.cfg['ssl'])

        s.send_registration()

        while True:
            data = s.socket.recv(4096)
            if not data:
                raise Exception('IrcClientReader: lost connection')
            cdebug(data)
            data = data.decode('utf-8')
            lines = data.split('\r\n')
            cdebug(lines)
            for line in lines:
                # Ignore blank lines
                if line == "":
                    continue

                #line = line.decode('utf-8')
                cdebug('line: "%s"' % line)

                # We only care about 3 commands. PING, JOIN and PRIVMSG.
                (who, cmd) = s.irc_decode(line)
                cdebug(cmd)
                if cmd[0] == '001':
                    cdebug('Registration Successful')
                    s.send_join()

                if cmd[0] == 'PING':
                    s.on_ping(line)

                elif cmd[0] == 'JOIN':
                    s.on_join(line)
                    s.send_join()

                elif cmd[0] == 'PRIVMSG':
                    # We care that the other end is alive, their version request is sufficient.
                    s.on_privmsg(line)

    def send(s, channel, line):
        center('IrcClient::send')
        cinfo("PRIVMSG {} :{}".format(channel, line))
        sent = s.raw_send('PRIVMSG %s :%s\r\n' % (channel, line))
        #sent = s.raw_send('NOTICE %s :%s\r\n' % (channel, line))
        cleave('IrcClient::send')


class MsgqReader(threading.Thread):

    def __init__(self, cmd_q, args, mq=None, secrets=None):
        super().__init__()

        self.daemon = True

        self.cmd_q = cmd_q
        self.mq = mq
        self.secrets = secrets

        self.queue = args.queue
        self.name = args.name
        self.direct = self.queue + '--' + args.name
        self.local = args.local

    # _handler
    #
    def _handler(self, payload):
        #print("MsgqReader _handler", payload)
        self.cmd_q.put(ClientCommand(ClientCommand.MSGQ_RAW, payload))

    # run
    #
    def run(self):
        try:
            if self.mq is None:
                # Pass in credentials if we have them, else use the limited defaults.
                hostname = self.secrets.data.get('amqp-hostname')
                username = self.secrets.data.get('amqp-username')
                password = self.secrets.data.get('amqp-password')
                credentials = None
                if username is not None and password is not None:
                    credentials = MsgQueueCredentials(username, password)

                self.mq = MsgQueueService(service='announce-announce', local=self.local, host=hostname, credentials=credentials, exchange='announce-todo', heartbeat_interval=60)
            print("Msgq", self.mq)

            self.mq.listen_worker(self.queue, 'announce.irc', self._handler)
            self.mq.listen_worker(self.direct, 'direct.{}.announce.irc'.format(self.name), self._handler, auto_delete=True)
            print("Listening", self.mq)
            self.mq.listen_start()

        except Exception as e:
            self.cmd_q.put(ClientCommand(ClientCommand.QUIT, e))
            raise e

    def deliver_to(self, payload):
        key = 'announce.' + payload['destination']['type']
        self.mq.publish_threadsafe(key, payload)


# TheApp
#
class TheApp():
    '''
    This class is just the engine that makes everything go.
    '''

    # __init__
    #
    def __init__(s, args):
        '''
        '''
        s.args = args

    # main
    #
    def main(self):

        retval = 1

        try:
            cmd_q = queue.Queue()

            irc_cfg = {
                "host"  : "irc.canonical.com",
                "port"    : 6697,
                'ssl'     : True,
                "password": None,
                "user"    : "kernel-bot",
                "nick"    : "shiv",
                "name"    : 'Kernel Bot',
                "channels": None,
            }

            secrets = Secrets(os.path.join(os.environ['HOME'], '.kernel-announcer-secrets.yaml'))
            for key in list(irc_cfg.keys()):
                value = secrets.data.get('irc-' + key)
                if value is None:
                    continue
                irc_cfg[key] = value

            irc = IrcEvents(irc_cfg, cmd_q)
            irc.start()

            mq = MsgqReader(cmd_q, args, secrets=secrets)
            mq.start()

            while True:
                cmd = cmd_q.get()
                print("WORKER:", cmd.type, cmd.data)

                if cmd.type == ClientCommand.QUIT:
                    break

                elif cmd.type == ClientCommand.IRC_RAW:
                    sender = cmd.data.get('from')
                    channel = cmd.data.get('channel')
                    message = cmd.data.get('message')
                    if message is None:
                        continue

                    cinfo("WORKER: POST {} {} {}".format(sender, channel, message))

                    nick = irc.cfg['nick']
                    if sender in ('StatServ', nick):
                        cinfo("WORKER: POST ignored")
                        continue

                    if channel == nick:
                        channel = sender

                    command = message
                    if command.startswith(nick + ',') or command.startswith(nick + ':'):
                        command = command[len(nick)+1:].strip()

                    source = {'type': 'irc', 'channel': channel}
                    destination = {'type': 'shankbot'}
                    message = {'subject': command}

                    payload = {'source': source, 'destination': destination, 'message': message}
                    print("APW: deliver_to", payload)
                    mq.deliver_to(payload)

                elif cmd.type == ClientCommand.MSGQ_RAW:
                    cinfo("MSGQ_RAW".format(cmd.data))

                    payload = cmd.data
                    what = payload.get('type', 'message')

                    if what == 'quit':
                        break

                    elif what == 'message':
                        destination = payload.get('destination', {})
                        message = payload.get('message', {})

                        text = message.get('summary', message.get('subject', '??'))
                        irc.send(destination.get('channel'), text)

                cmd_q.task_done()

            #mm.join()
            #mq.join()

            print("Exiting")
            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            print("Aborting ...")

        return retval

if __name__ == '__main__':
    app_description = '''
I'm a application skeleton, your job is to make me into something useful.
    '''
    parser = ArgumentParser(description=app_description)
    parser.add_argument('--debug', action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--local', action='store_true', default=False, help='Assume we have sshuttle setup to the MQ server.')
    parser.add_argument('--name', default=os.uname().nodename, help='Name of this instance in the admin domain')
    parser.add_argument('--queue', default='announce-irc', help='Name of the queue to use')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    logging.basicConfig(format="%(levelname)05s - %(message)s", level=logging.DEBUG if args.debug else logging.INFO)
    logger = logging.getLogger('announce-irc')
    #logging.setLevel(level=logging.DEBUG if args.debug else logging.INFO)

    app = TheApp(args)
    exit(app.main())


# vi:set ts=4 sw=4 expandtab:

