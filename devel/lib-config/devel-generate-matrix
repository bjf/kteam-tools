#!/usr/bin/python3

import sys
import os
import re

(fmt, prefix, order) = sys.argv[1:4]
config_files = sys.argv[4:]


# Load up the annotations, extracting the policy specifiers.
info_option = re.compile(r'\s*(\S+)<(.*?)>')
annot = {}
note = {}

form = 1

for line in sys.stdin:
    line = line.strip()

    if line.startswith("# FORMAT: "):
        a = line.split(None, 2)
        if a[2] != 2:
            print("ERROR: unknown format", file.sys.stderr)
            os.exit(1)
        form = a[2]

    if not line.startswith('CONFIG_'):
        continue

    if form == 1:
        a = line.split(None, 2)
        while len(a) < 3:
            a.append('')
        (config, value, options) = a

        # Compatibility
        if value not in ('-', 'p', 'C'):
            options += " policy<{'*': '" + value + "'}>"

    # Version 2: config and options only, we never use the format.
    elif form == 2:
        a = line.split(None, 1)
        (config, options) = a
        

    rec = annot.setdefault(config, {})

    for match in info_option.finditer(options):
        cmd = match.group(1)
        if cmd == 'policy':
            try:
                pol = eval(match.group(2))
                if cmd in rec and rec[cmd] != pol:
                    print("ERROR: {}: duplicate policy '{}' '{}'".format(config, rec[cmd], match.group(2)))
                rec[cmd] = pol
            except SyntaxError:
                print("ERROR: {}: invalid policy '{}'".format(config, match.group(2)))
                rec[cmd] = None

        elif cmd == 'flag':
            tmp = rec.setdefault(cmd, {})
            tmp[match.group(2)] = True

        elif cmd not in rec:
            rec[cmd] = match.group(2)

    # Let a simple wildcard be specified via value.
    if 'value' in rec and 'policy' not in rec:
        rec['policy'] = {'*': rec['value'] }


for key in annot:
    rec = annot[key]
    if 'flag' in rec:
        for key in rec['flag']:
            rec['note'] = rec.get('note', '') + ' ' + key


def policy_lookup(policy, arch, flavour):
    want = '-'
    for which in [arch + '-' + flavour, arch + '-*', '*-' + flavour, arch, '*']:
        if which in policy:
            want = policy[which]
            break
    return want 


# Load up the per flavour configs.
values = {}
configs = []
for config in config_files:
    name = os.path.basename(config.replace('-config.flavour.', ' '))
    (arch, flavour) = name.split(' ')
    configs.append((arch, flavour))

    with open(config) as configf:
        for line in configf:
            if line.startswith('CONFIG_'):
                (config, value) = line.strip().split('=', 1)
            elif line.startswith('# CONFIG_'):
                (config, value) = (line.strip().split()[1], 'n')
            else:
                continue
            values[(arch, flavour, config)] = value


def emit_header_html(title):
    res =  """\
<html>
<head>
<title>{title}</title>
<style>
#.row:nth-child(6n+1) {{ background-color: #eeeeee; }}
#.row:nth-child(6n+2) {{ background-color: #eeeeee; }}
#.row:nth-child(6n+3) {{ background-color: #eeeeee; }}
#.row:nth-child(even) {{ background-color: lightgrey }}
.row_good3 {{ background-color: #eeeeee; }}
.row_good4 {{ background-color: #eeeeee; }}
.row_good5 {{ background-color: #eeeeee; }}
.row_bad {{ background-color: #ffbac8; }}
.row_warn {{ background-color: #eee8aa; }}
#.cell_bad {{ color: red; }}
table.matrix {{
    border-collapse: collapse;
}}
table.matrix th {{
    text-align: left;
}}
table.matrix td {{
    padding: 5px;
}}
.pointer {{ cursor: pointer; }}
</style>
</head>""".format(title=title)

    return res


def emit_html(entries):
    title = entries.pop(0)
    title = title.replace('>>', ' >> ')
    interesting = False

    res  = "<h2>" + title + "</h2>\n"

    res += "<table class=\"matrix\">\n"
    res += "<tr class=\"row\"><th>Option"
    for config in configs:
        res += "<th>" + ' '.join(config)
    res += "<th>Notes</tr>\n"

    count = -1
    for entry in entries:
        count = (count + 1) % 6

        (config, vals) = (entry[0], entry[1:])
        tmp = annot.get(config, {})

        rcls = "row_good" + str(count)
        cells = ''
        row_interesting = False
        for (column, entry) in zip(configs, vals):
            if entry != '-':
                row_interesting = True
            (arch, flavour) = column
            cls = "cell_good"
            if 'policy' in tmp and tmp['policy']:
                want = policy_lookup(tmp['policy'], arch, flavour)
                if want != entry:
                    cls = "cell_bad"
                    rcls = "row_bad"
                    entry += "&nbsp;(&rarr;" + want + ")"
                    interesting = True
            elif row_interesting:
                rcls = "row_warn"
                interesting = True
            cells += "<td class=\"" + cls + "\">" + entry
        if row_interesting:
            res += "<tr class=\"row " + rcls + "\"><td>" + config 
            res += cells
            res += "<td>" + tmp.get('note', '') + "</tr>\n"
    
    res += "</table>"

    return (interesting, res)


def emit_footer_html():
    return """\
</body>
</html>
"""

if fmt == 'html':
    emit_header = emit_header_html
    emit = emit_html
    emit_footer = emit_footer_html


else:
    print("UKNOWN FORMAT")
    sys.exit(1)


out_full = open(prefix + "." + fmt, "w")
out_issues = open(prefix + "-issues." + fmt, "w")
out_review = open(prefix + "-review." + fmt, "w")

print(emit_header('Config Review -- Detail'), file=out_full)
print(emit_header('Config Review -- Issues'), file=out_issues)
print(emit_header('Config Review -- Review Items'), file=out_review)


def emit_record(record):
    (interesting, data) = emit(entries)

    if interesting:
        print(data, file=out_issues)
    print(data, file=out_full)


# Emit the menus in order.
marked = {
    'EXPERIMENTAL': [ 'EXPERIMENTAL Options' ],
    'DANGEROUS':    [ 'DANGEROUS Options' ],
    'STAGING':      [ 'STAGING Options' ],
}
entries = []
with open(order) as orderf:
    for line in orderf:
        if line[0] == 'M':
            if len(entries):
                emit_record(entries)

            title = line.strip()[8:]
            entries = [ title ]

        elif line[0] == 'E':
            config = line.strip().split('>>>')[1]
            which = 'CONFIG_' + config
            columns = [ which ]
            for config in configs:
                (arch, flavour) = config
                columns.append(values.get((arch, flavour, which), '-'))

            entries.append(columns)

            #print(annot.get(which, {}))
            flags = annot.get(which, {}).get('flag', {})
            for mark in marked:
                if mark in flags:
                    marked[mark].append(columns)


if len(entries):
    emit_record(entries)

for flag in sorted(marked.keys()):
    (interesting, data) = emit(marked[flag])
    print(data, file=out_review)

# Close the reports off.
print(emit_footer(), file=out_review)
print(emit_footer(), file=out_issues)
print(emit_footer(), file=out_full)

out_review.close()
out_issues.close()
out_full.close()
