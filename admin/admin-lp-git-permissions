#!/usr/bin/python3
from __future__ import print_function

from copy                               import deepcopy
import json
import os
import sys
import yaml

from launchpadlib.launchpad             import Launchpad

# Add ../libs to the Python search path
sys.path.append(os.path.realpath(os.path.join(os.path.dirname(__file__),
                                              os.pardir, 'libs')))

from ktl.kernel_series                  import KernelSeries


lp = Launchpad.login_with('admin-lp-git-permissions', 'production', version='devel')

cmd = sys.argv[1]

def generate_grant(create=False, push=False, rewind=False, person=None):
    grant = {}

    if person == 'owner':
        grant['grantee_type'] = "Repository owner"
        grant['grantee_link'] = None
    elif person:
        grant['grantee_type'] = "Person"
        grant['grantee_link'] = 'https://api.launchpad.net/devel' + person
    else:
        raise ValueError("owner or person required")

    grant['can_create'] = create
    grant['can_push'] = push
    grant['can_force_push'] = rewind

    return grant

def sort_grants(grants):
    return sorted(deepcopy(grants), key=lambda x: (x['grantee_type'], x['grantee_link']))

if cmd == 'list-all':
    me = lp.people(sys.argv[2])
    for repo in lp.git_repositories.getRepositories(target=me):
        print(repo)
        current_rules = repo.getRules()
        rule_txt = yaml.dump(current_rules, default_flow_style=False)
        for line in rule_txt.split('\n'):
            print("  " + line)

elif cmd == 'sync-misc':

    branch = 'master'

    admins = '/~canonical-kernel-repo-admins'
    rules = []

    grants = []
    for person in (
            "/~canonical-kernel-committers",
            "/~canonical-kernel-hwe-committers",
            "/~arighi",
            ):
        grants.append(generate_grant(person=person, push=True))
    grants.append(generate_grant(person=admins, create=True, push=True, rewind=True))
    if admins != 'owner':
        grants.append(generate_grant(person='owner'))
    rules.append(
        {
            'ref_pattern': "refs/heads/{}".format(branch),
            'grants': sort_grants(grants),
        },
        )

    print(" want:")
    rule_txt = yaml.dump(rules, default_flow_style=False)
    for line in rule_txt.split('\n'):
        print("  " + line)

    git_repo = lp.git_repositories.getByPath(path="~canonical-kernel/+git/kteam-tools")
    rules_are = git_repo.getRules()

    print(" have:")
    rule_txt = yaml.dump(rules_are, default_flow_style=False)
    for line in rule_txt.split('\n'):
        print("  " + line)

    git_repo.setRules(rules=rules)

elif cmd == 'sync-all':
    #for person in (lp.people('ubuntu-kernel'), lp.people('canonical-kernel')):
    #    for repo in lp.git_repositories.getRepositories(target=person):
    #        print(repo, repo.getRules())
    #
    # rules = generate_rules(owner_all=True, people=[
    #     '/~canonical-kernel-committers',
    #     '/~canonical-kernel-hwe-committers',
    #     ])
    #
    #print(json.dumps(uules, sort_keys=True, indent=4))

    kernel_series = KernelSeries()

    repo_packages = {}

    for series in sorted(kernel_series.series, key=KernelSeries.key_series_name):
        if series.opening_ready('repositories') is False:
            continue

        for source in sorted(series.sources, key=lambda x: x.name):
            #if series.codename != 'bionic':
            #    continue

            for package in source.packages:
                if package.repo is None:
                    continue
                url = package.repo.url

                if 'git.launchpad.net' not in url:
                    continue

                bits = url.split('~', 1)
                if len(bits) != 2:
                    continue

                path = '~' + bits[1]

                repo_packages.setdefault(path, []).append(package)
                #branch = package.repo.branch
                #repo_packages.setdefault(path, []).append(branch)
                #if branch.endswith('-next'):
                #    repo_packages.setdefault(path).append(branch[:-5])

    for (path, path_packages) in repo_packages.items():
        rules = []
        rules_wild = []
        versions = set()

        any_supported = False
        for package in path_packages:
            if package.source.development is False and package.source.supported is False:
                continue
            any_supported = True
            print(package, package.source.development, package.source.supported)

            people = ['/~canonical-kernel-committers']
            if package.name.endswith('oem') or '-oem-' in package.name:
                people.append('/~canonical-kernel-hwe-committers')
            #admins = 'owner'
            #if series.esm or package.name.endswith('ibm-gt'):
            #    admins = '/~canonical-kernel-repo-admins'
            # XXX: until we drop people from the ubuntu-kernel and canonical-kernel
            #      we need to bodge their admin-ness away.
            admins = '/~canonical-kernel-repo-admins'

            branch = package.repo.branch
            branches = []
            # Order here matters to launchpad, see LP: #1815431.
            if branch.endswith('-next'):
                branches.append(branch[:-5])
            branches.append(branch)
            for branch in branches:
                if package.series.development:
                    rewind = True
                elif package.source.derived_from is not None and package.type is None:
                    rewind = True
                elif branch.endswith('-next'):
                    rewind = True
                else:
                    rewind = False
                grants = []
                for person in people:
                    grants.append(generate_grant(person=person, create=True, push=True, rewind=rewind))
                rules.append(
                    {
                        'ref_pattern': "refs/heads/{}".format(branch),
                        'grants': sort_grants(grants),
                    },
                    )

            # TAGS: allow Ubuntu-<branch>- prefixed tags.
            branch_prefix = package.source.name.replace('linux', '')
            if branch_prefix.startswith('-lts-'):
                branch_prefix = '-lts'
            rewind_tags = series.development
            grants = []
            for person in people:
                grants.append(generate_grant(person=person, create=True, rewind=rewind_tags))
            rules_wild.append(
                {
                    'ref_pattern': "refs/tags/Ubuntu{}-[0-9]*".format(branch_prefix),
                    'grants': sort_grants(grants),
                },
                )

            # TAGS: for main packages allow version tags to be pushed too.
            if package.type in (None, 'main'):
                pkg_versions = package.source.versions
                if pkg_versions is not None:
                    for version in pkg_versions:
                        versions.add(version)

        # Add the administrator rules.
        grants = []
        series = path_packages[0].series
        if any_supported:
            grants.append(generate_grant(person=admins, create=True, push=True, rewind=True))
            if admins != 'owner':
                grants.append(generate_grant(person='owner'))
        else:
            grants.append(generate_grant(person='owner'))

        for version in versions:
            if version.endswith('.0'):
                version = version[:-2]
            rules_wild.append(
                {
                    'ref_pattern': "refs/tags/v{}*".format(version),
                    'grants': sort_grants(grants),
                },
                )

        rules_wild.append(
            {
                'ref_pattern': "*",
                'grants': sort_grants(grants),
            },
            )


        # XXX: build rules to avoid launchpad Assertion.
        rules_wild = sorted(rules_wild, key=lambda x: x['ref_pattern'])
        rules = sorted(rules, key=lambda x: x['ref_pattern'])
        rules += rules_wild

        git_repo = lp.git_repositories.getByPath(path=path)
        if git_repo is None:
            print("  invalid repository path {} for {}".format(path, package.name))
            continue
        print(git_repo)
        current_rules = git_repo.getRules()
        if current_rules != rules:
            print(" is:")
            rule_txt = yaml.dump(current_rules, default_flow_style=False)
            for line in rule_txt.split('\n'):
                print("  " + line)
            print(" want:")
            rule_txt = yaml.dump(rules, default_flow_style=False)
            for line in rule_txt.split('\n'):
                print("  " + line)
            print(" rules updated:")
            git_repo.setRules(rules=rules)
        sys.stdout.flush()
