#!/usr/bin/python3
from __future__ import print_function

from copy                               import deepcopy
import json
import os
import sys
import yaml

from launchpadlib.launchpad             import Launchpad

# Add ../libs to the Python search path
sys.path.append(os.path.realpath(os.path.join(os.path.dirname(__file__),
                                              os.pardir, 'libs')))

from ktl.kernel_series                  import KernelSeries


lp = Launchpad.login_with('admin-lp-git-permissions', 'production', version='devel')

cmd = sys.argv[1]

def generate_grant(create=False, push=False, rewind=False, person=None):
    grant = {}

    if person == 'owner':
        grant['grantee_type'] = "Repository owner"
        grant['grantee_link'] = None
    elif person:
        grant['grantee_type'] = "Person"
        grant['grantee_link'] = 'https://api.launchpad.net/devel' + person
    else:
        raise ValueError("owner or person required")

    grant['can_create'] = create
    grant['can_push'] = push
    grant['can_force_push'] = rewind

    return grant

def sort_grants(grants):
    return sorted(deepcopy(grants), key=lambda x: (x['grantee_type'], x['grantee_link']))

def update_rules(git_repo, rules, show=False):
    # Get and sort the rules so we can compare against them.
    current_rules = git_repo.getRules()
    for rule in current_rules:
        rule['grants'] = sort_grants(rule['grants'])

    if current_rules != rules or show is True:
        print(" is:")
        rule_txt = yaml.dump(current_rules, default_flow_style=False)
        for line in rule_txt.split('\n'):
            print("  " + line)

    if current_rules != rules:
        print(" want:")
        rule_txt = yaml.dump(rules, default_flow_style=False)
        for line in rule_txt.split('\n'):
            print("  " + line)
        print(" rules updated")
        git_repo.setRules(rules=rules)

def update_subscriptions(git_repo, crankers):
    if not git_repo.private:
        return

    # For private repositories we need to add an empty subscription
    # for each cranker.  Look up all the existing subscriptions.
    subscriber_seen = set()
    for subscription in git_repo.subscriptions:
        #print(subscription, subscription.person)
        subscriber_seen.add(subscription.person.name)

    for cranker in crankers:
        cranker = cranker[2:]
        if cranker not in subscriber_seen:
            person = lp.people(cranker)
            print(" cranker:")
            print("  " + cranker)
            git_repo.subscribe(person=person,
                code_review_level='No email',
                max_diff_lines="Don't send diffs",
                notification_level='No email')

def sync_misc():
    admins = '/~canonical-kernel-repo-admins-active'

    for repo_path in (
            '~canonical-kernel/+git/kteam-tools',
            '~canonical-kernel/+git/adt-matrix-hints',
        ):

        branch = 'master'

        rules = []
        grants = []

        for person in (
                "/~canonical-kernel-committers",
                "/~canonical-kernel-hwe-committers",
                "/~canonical-kernel-tools-committers",
                ):
            grants.append(generate_grant(person=person, push=True))
        grants.append(generate_grant(person=admins, create=True, push=True, rewind=True))
        if admins != 'owner':
            grants.append(generate_grant(person='owner'))
        rules.append(
            {
                'ref_pattern': "refs/heads/{}".format(branch),
                'grants': sort_grants(grants),
            },
            )

        git_repo = lp.git_repositories.getByPath(path=repo_path)
        print(git_repo)
        update_rules(git_repo, rules)
        sys.stdout.flush()

def sync_esm():
    admins = '/~canonical-kernel-repo-admins-active'

    kernel_series = KernelSeries()


    in_esm = set()
    for series in sorted(kernel_series.series, key=KernelSeries.key_series_name):
        if not series.esm:
            continue
        in_esm.add(series.codename)

    grants = []
    grants.append(generate_grant(person=admins, create=True, push=True, rewind=True))
    if admins != 'owner':
        grants.append(generate_grant(person='owner'))
    rules = [
        {
        'ref_pattern': "*",
        'grants': sort_grants(grants),
        },
        ]

    for team_name in ('ubuntu-kernel', 'canonical-kernel'):
        team = lp.people(team_name)
        for git_repo in lp.git_repositories.getRepositories(target=team):
            bits = git_repo.self_link.split('/')
            if bits[-2] != '+git' or bits[-1] not in in_esm:
                continue
            print(git_repo, 'ESM')
            update_rules(git_repo, rules)
            sys.stdout.flush()

def sync_primary():
    admins = '/~canonical-kernel-repo-admins-active'

    #for person in (lp.people('ubuntu-kernel'), lp.people('canonical-kernel')):
    #    for repo in lp.git_repositories.getRepositories(target=person):
    #        print(repo, repo.getRules())
    #
    # rules = generate_rules(owner_all=True, people=[
    #     '/~canonical-kernel-committers',
    #     '/~canonical-kernel-hwe-committers',
    #     ])
    #
    #print(json.dumps(uules, sort_keys=True, indent=4))

    kernel_series = KernelSeries()

    repo_packages = {}

    for series in sorted(kernel_series.series, key=KernelSeries.key_series_name):
        if series.opening_ready('repositories') is False:
            continue

        for source in sorted(series.sources, key=lambda x: x.name):
            #if series.codename != 'bionic':
            #    continue

            for package in source.packages:
                if package.repo is None:
                    continue
                url = package.repo.url

                if 'git.launchpad.net' not in url:
                    continue

                bits = url.split('~', 1)
                if len(bits) != 2:
                    continue

                path = '~' + bits[1]

                repo_packages.setdefault(path, []).append(package)
                #branch = package.repo.branch
                #repo_packages.setdefault(path, []).append(branch)
                #if branch.endswith('-next'):
                #    repo_packages.setdefault(path).append(branch[:-5])

    for (path, path_packages) in repo_packages.items():
        rules = []
        rules_wild = []
        versions = set()
        crankers = ['/~canonical-kernel-crankers']

        any_supported = False
        for package in path_packages:
            if package.source.development is False and package.source.supported is False:
                continue
            any_supported = True
            print(package, package.source.development, package.source.supported)

            people = ['/~canonical-kernel-committers']
            if package.name.endswith('oem') or '-oem-' in package.name:
                people.append('/~canonical-kernel-hwe-committers')
            #admins = 'owner'
            #if series.esm or package.name.endswith('ibm-gt'):
            #    admins = '/~canonical-kernel-repo-admins'
            # XXX: until we drop people from the ubuntu-kernel and canonical-kernel
            #      we need to bodge their admin-ness away.

            branch = package.repo.branch
            branches = []
            # Order here matters to launchpad, see LP: #1815431.
            if branch.endswith('-next'):
                branches.append(branch[:-5])
                if package.type in (None, 'main'):
                    branches.append(branches[-1] + '-current')
            branches.append(branch)
            for branch in branches:
                if package.series.development:
                    rewind = True
                elif package.source.derived_from is not None and package.type is None:
                    rewind = True
                elif branch.endswith('-next') or branch.endswith('-current'):
                    rewind = True
                else:
                    rewind = False
                grants = []
                for person in people:
                    grants.append(generate_grant(person=person, create=True, push=True, rewind=rewind))
                rules.append(
                    {
                        'ref_pattern': "refs/heads/{}".format(branch),
                        'grants': sort_grants(grants),
                    },
                    )

            # TAGS: allow Ubuntu-<branch>- prefixed tags.
            branch_prefix = package.source.name.replace('linux', '')
            branch_prefixes = [ branch_prefix ]
            if branch_prefix.startswith('-lts-'):
                branch_prefixes.append('-lts')
            rewind_tags = series.development
            grants = []
            for person in people:
                grants.append(generate_grant(person=person, create=True, rewind=rewind_tags))
            for branch_prefix in branch_prefixes:
                rules_wild.append(
                    {
                        'ref_pattern': "refs/tags/Ubuntu{}-[0-9]*".format(branch_prefix),
                        'grants': sort_grants(grants),
                    },
                    )

            # TAGS: for main packages allow version tags to be pushed too.
            if package.type in (None, 'main'):
                pkg_versions = package.source.versions
                if pkg_versions is not None:
                    for version in pkg_versions:
                        versions.add(version)

        # Add the administrator rules.
        grants = []
        series = path_packages[0].series
        grants.append(generate_grant(person=admins, create=True, push=True, rewind=True))
        if admins != 'owner':
            grants.append(generate_grant(person='owner'))

        for version in versions:
            if version.endswith('.0'):
                version = version[:-2]
            rules_wild.append(
                {
                    'ref_pattern': "refs/tags/v{}*".format(version),
                    'grants': sort_grants(grants),
                },
                )

        rules_wild.append(
            {
                'ref_pattern': "*",
                'grants': sort_grants(grants),
            },
            )


        # XXX: build rules to avoid launchpad Assertion.
        rules_wild = sorted(rules_wild, key=lambda x: x['ref_pattern'])
        rules = sorted(rules, key=lambda x: x['ref_pattern'])
        rules += rules_wild

        git_repo = lp.git_repositories.getByPath(path=path)
        if git_repo is None:
            print("  invalid repository path {} for {}".format(path, package.name))
            continue
        print(git_repo)
        update_rules(git_repo, rules)
        update_subscriptions(git_repo, crankers)

        sys.stdout.flush()


if cmd == 'list-all':
    me = lp.people(sys.argv[2])
    for repo in lp.git_repositories.getRepositories(target=me):
        print(repo)
        current_rules = repo.getRules()
        rule_txt = yaml.dump(current_rules, default_flow_style=False)
        for line in rule_txt.split('\n'):
            print("  " + line)
        sys.stdout.flush()

elif cmd == 'sync-misc':
    sync_misc()

elif cmd == 'sync-esm':
    sync_esm()

elif cmd == 'sync-primary':
    sync_primary()

elif cmd == 'sync-all':
    print("SYNC: primary")
    sync_primary()
    print("SYNC: esm")
    sync_esm()
    print("SYNC: misc")
    sync_misc()
