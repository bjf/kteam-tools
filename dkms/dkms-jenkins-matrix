#!/usr/bin/python

from __future__ import print_function

import ast
import urllib2
import re
import os
import sys
import apt_pkg
import shlex

from operator import itemgetter
from optparse import OptionParser
from functools import cmp_to_key

parser = OptionParser()
parser.add_option("-v", "--versions", type="int", help="Number of versions to show in the matrix")
parser.add_option("", "--urlmap", type="string", action="append", nargs=2, help="URL mapping <from> <to>")
parser.add_option("-r", "--regressions", action="store_true", help="Regressions Summary")

(options, args) = parser.parse_args()

#url = 'http://jenkins.qa.ubuntu.com/view/DKMS/view/U%20-generic'
#url = 'http://jenkins.qa.ubuntu.com/view/DKMS/view/T%20Proposed%20-generic/'

apt_pkg.init_system()

packages = {}
groups = []
for line in sys.stdin:
    a = shlex.split(line.strip())
    (link, group, urls) = (a[0], a[1], a[2:])

    versions = {}
    jobs = {}
    links = {}
    regression = {}
    limit = None
    for url in urls:
        if url.startswith("--limit="):
            limit = url[8:]
            continue

        tree = ast.literal_eval(urllib2.urlopen(url + '/api/python?depth=2').read().decode('utf-8'))

        for job in tree['jobs']:
            #print(job['name'], file=sys.stderr)
            #print(job['description'], file=sys.stderr)
            name = job['name'].split('-').pop()

            #print(job['builds'][0])
            seen = False
            last_version = None
            # Ensure we treat runs in latest build in the latest kernel first order.
            for build in sorted(job['builds'], key=itemgetter('number', 'timestamp')):
                #print(build['description'], file=sys.stderr)
                if 'description' not in build or not build['description']:
                    continue
                (kver, pver) = build['description'].split(' ')[0:2]
                if '-' not in kver:
                    continue
                (pkg, pver) = pver.split('/')
                if pkg == '':
                    continue

                if build['result'] == 'SUCCESS':
                    status = 'GOOD'
                elif build['result'] == None:
                    status = 'RUN'
                else:
                    status = 'FAIL'

                ##print(name, kver, pver, status)
                packages[name] = True
                versions[kver] = True
                jobs[name, kver] = status
                links[name, kver] = build['url']
                last_version = kver

        if limit == 'first-newest':
            limit = last_version

    vlist = sorted(versions.keys(), key=cmp_to_key(apt_pkg.version_compare))

    # Apply history to determine if a FAIL is a regression (REGR).
    for package in packages:
        good = False
        for version in vlist:
            status = jobs.get((package, version))
            if status == 'GOOD':
                good = True
            elif good and status == 'FAIL':
                jobs[package, version] = 'REGR'

    # Determine if each version is a regression on the previous one.
    prev = vlist[0]
    for version in vlist[1:]:
        regression[version] = False
        for package in packages:
            pstatus = jobs.get((package, prev))
            status = jobs.get((package, version))

            if pstatus == 'GOOD' and status != 'GOOD':
                regression[version] = True
        prev = version

    if options.versions:
        vlist = vlist[-options.versions:]

    # Limit the versions by lower version bound.
    if limit:
        vlist = [v for v in vlist if apt_pkg.version_compare(v, limit) >= 0]

    groups.append((group, link, vlist, jobs, links, regression))


if options.regressions:
    for (group, link, vlist, jobs, links, regression) in groups:
        for version in vlist:
            print(group + ":" + version + ":" + str(regression.get(version)))
    sys.exit(0)

packages = sorted(packages)

print("""<html>
<head>
<title>DKMS Matrix</title>
<style>
.GOOD { background-color: green; }
.RUN { background-color: yellow; }
.FAIL { background-color: orange; }
.REGR { background-color: red; }
table.matrix {
    border-collapse: collapse;
}
table.matrix, table.matrix th, table.matrix td {
   border: 1px solid black;
} 
</style>
</head>
<body>
<h1>DKMS Matrix</h1>
<table class="matrix">
""")

print("<tr><th>")
cols = []
for (group, link, vlist, jobs, links, regression) in groups:
    if link != '-':
        fmt = '<th colspan="{0}"><a href="{1}">{2}</a>'
    else:
        fmt = '<th colspan="{0}">{2}'
    cols.append(fmt.format(str(len(vlist)), link, group))
print("<th>&nbsp;".join(cols))
print("<th></tr>")
    
print("<tr><th>")
cols = []
for (group, link, vlist, jobs, links, regression) in groups:
    grp = ''
    for version in vlist:
        grp += "<th>" + version
    cols.append(grp)
print("<th>&nbsp;".join(cols))
print("<th></tr>")

for package in sorted(packages):
    print("<tr><th>" + package)
    cols = []
    for (group, link, vlist, jobs, links, regression) in groups:
        grp = ''
        for version in vlist:
            fmt = '<td class="{0}"><a href="{1}">{2}</a>'
            if (package, version) in links:
                url = links[package, version]
                #(chg, to) = ('http://jenkins.qa.ubuntu.com/', 'http://d-jenkins.ubuntu-ci:8080/')
                if options.urlmap:
                    for (chg, to) in options.urlmap:
                        if url.startswith(chg):
                            url = to + url[len(chg):]
            else:
                fmt = '<td class="{0}">{2}'
                url = None
            status = jobs.get((package, version), '&nbsp;')
            grp += fmt.format(status, url, status)
        cols.append(grp)
    print("<th>&nbsp;".join(cols))
    print("<th>" + package + "</tr>")

print("""</table>
</body>
</html>""")
