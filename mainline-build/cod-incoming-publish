#!/bin/bash
#
# cod-incoming-publish -- pull publishable images out of incoming and 
# install them, upload them, and/or announce them as required.
#
P="cod-incoming-publish"

here=`dirname $0`
case "$here" in
/*) ;;
*)  here="`pwd`/$here" ;;
esac

incoming="$HOME/incoming"
lock_tmp="$incoming/.LOCK-$$"
lock="$incoming/.LOCK"

out="$HOME/public_html"

# One at a time please...
mkdir -p "$incoming"

echo "$$" >"$lock_tmp"
while ! ln "$lock_tmp" "$lock" 2>/dev/null
do
    echo "$P: incoming locked ... waiting" 1>&2
    sleep 15
done
rm -f "$lock_tmp"

# Pull out any published images ...
if [ -d "$incoming/mainline" ]; then
	echo "Scanning mainline ..."
	outgoing="$HOME/public_html/mainline"
	(cd "$incoming/mainline" && find . -name COMMIT) | \
	while read commit
	do
		build=`dirname "$commit"`
		build=${build#./}

		echo "$P: $build: mainline publishing ..."
		announce='build'
		if [ -d "$outgoing/$build" ]; then
			echo "$P: $build: result already published, removing previous ..."
			rm -rf "$outgoing/$build"
			announce='rebuild'
		fi
		mkdir -p "$outgoing/`dirname "$build"`"
		mv "$incoming/mainline/$build" "$outgoing/$build" && \
		{
			# Sign the publication.
			rm -f "$outgoing/$build/CHECKSUMS.gpg"
			gpg -a -b --sign --output "$outgoing/$build/CHECKSUMS.gpg" "$outgoing/$build/CHECKSUMS"

			# Only announce top level results.
			case "$build" in
			*/*)	announce='' ;;
			esac
		}
		if [ "$announce" != '' ]; then
			echo "$P: $build: announcing ..."
			"$here/mainline-announce" `head -1 "$outgoing/$build/COMMIT"` "$build" "$announce" "$outgoing/$build/BUILT"
		fi
	done
	find "$incoming/mainline" -empty -type d -delete

	# Re-evaluate any 'current' links.
	(
		cd "$outgoing" || exit 1

		find . -name current | \
		while read current
		do
			dir=`dirname "$current"`
			latest=`ls -1 "$dir" | grep -v '^current$' | tail -1`

			is=`readlink "$current"`
			if [ "$is" != "$latest" ]; then
				echo "$P: $dir: updating current to $latest"
				rm -f "$current"
				ln -s "$latest" "$current"
			fi
		done
	)
fi

if [ -d "$incoming/upload" ]; then
	echo "Scanning upload ..."
	# Look for any uploads for various PPAs.
	for ppa in 'test-devel' 'pre-proposed'
	do
		(
			[ ! -d "$incoming/upload/$ppa" ] && exit 0
			cd "$incoming/upload/$ppa" || exit 1
			mkdir -p failed

			for package in *_source.changes
			do
				package=${package%_source.changes}
				if [ "$package" = "*" ]; then
					continue
				fi

				echo "$P: $package: uploading ..."

				# Sign the package we are meant to be uploading.
				echo "n" | debsign -kkernel-ppa "${package}_source.changes"

				# And upload it.
				dput "$ppa" ${package}_source.changes && \
					rm -f "${package}"* || mv "${package}"* failed
			done
		)
	done
	find "$incoming/upload" -empty -type d -delete
fi

if [ -d "$incoming/native" ]; then
	echo "Scanning native ..."
	# Look for any source packages for the native PPA builders.
	(
		cd "$incoming/native/source" || exit 1

		for package in *_source.changes
		do
			package=${package%_source.changes}
			if [ "$package" = "*" ]; then
				continue
			fi

			echo "$P: $package: mainline-native job queueing ..."

			# Sign the package we are meant to be uploading.
			echo "n" | debsign -kkernel-ppa "${package}_source.changes"

			# Move it to the queue directory so we only queue it once.
			mkdir -p "$incoming/native/queue"
			mv -f "${package}"* "$incoming/native/queue"

			# Queue it up.
			"$here/cod-enqueue" --to mainline-native "cod-mainline-native-build" "${package}"
		done
	)
	# Look for any completed native builds.
	(
		outgoing="$outgoing/native"

		[ ! -d "$incoming/native/publish" ] && exit 0
		mkdir -p "$outgoing"
		cd "$incoming/native/publish" || exit 1
		for prefix in *
		do
			if [ "$prefix" = "*" ]; then
				continue
			fi
			# Identify the build.
			{
				read commit
				read sha1
			} <"$prefix/COMMIT"
			build="$commit"

			echo "$P: $build: native build publishing ..."

			mkdir -p "$outgoing"
			if [ -d "$outgoing/$build" ]; then
				echo "$P: $build: result already published, removing previous ..."
				rm -rf "$outgoing/$build"
			fi
			mv "$prefix" "$outgoing/$build" && \
			{
				# Sign the publication.
				rm -f "$outgoing/$build/CHECKSUMS.gpg"
				gpg -a -b --sign --output "$outgoing/$build/CHECKSUMS.gpg" "$outgoing/$build/CHECKSUMS"
			}
		done
	)
	find "$incoming/native" -empty -type d -delete
fi

# Copy in incoming configuration dumps.
mkdir -p "$out/config"
if [ -d "$incoming/config" ]; then
	echo "Scanning config ..."
	rsync -v -a --remove-source-files "$incoming/config/" "$out/config/"
	find "$incoming/config" -empty -type d -delete
fi


if [ -d "$incoming/test-build" ]; then
	echo "Scanning test-build ..."
	(cd "$incoming/test-build" && find . -name SUMMARY) | \
	while read summary
	do
		build=`dirname "$summary"`
		build=${build#./}

		echo "$P: $build: test-build publishing ..."
		announce='build'
		if [ -d "$out/test-build/$build" ]; then
			echo "$P: $build: result already published, removing previous ..."
			rm -rf "$out/test-build/$build"
			announce='rebuild'
		fi
		mkdir -p "$out/test-build/`dirname "$build"`"
		mv "$incoming/test-build/$build" "$out/test-build/$build"
		echo "$P: $build: announcing ..."
		"$here/cod-changeset-announce" "$out/test-build/$build" "$announce"
	done
	find "$incoming/test-build" -empty -type d -delete

	# Rebuild the summaries.
	(
		cd "$out/test-build" || exit 1

		for sp in */*
		do
			[ ! -d "$sp" ] && continue

			"$here/cod-changeset-summary" "$sp" "$sp"
			mv -f "$sp/index.html.new" "$sp/index.html"
			mv -f "$sp/latest.json.new" "$sp/latest.json"
		done
	)
	# Rebuild the dashboard.
	"$here/cod-changeset-dashboard" "$out/test-build"
	mv -f "$out/test-build/index.html.new" "$out/test-build/index.html"
fi

if [ -d "$incoming/ubuntu-stable" ]; then
	echo "Scanning ubuntu-stable ..."
	(cd "$incoming/ubuntu-stable" && find . -name @publish@) | \
	while read result
	do
		build=`dirname "$result"`
		build=${build#./}

		echo "$P: $build: ubuntu-stable publishing ..."
		submit=0
		if [ -f "$incoming/ubuntu-stable/$build/core.summary" ]; then
			submit=1
			if [ -d "$out/ubuntu-stable/$build" ]; then
				echo "$P: $build: result already published, removing previous ..."
				rm -rf "$out/ubunu-stable/$build"
			fi
		fi
		mkdir -p "$out/ubuntu-stable/$build"
		rm -f "$incoming/ubuntu-stable/$build/@publish@"
		mv "$incoming/ubuntu-stable/$build"/* "$out/ubuntu-stable/$build"
		if [ "$submit" = 1 ]; then
			# Now we have installed the core result, submit our builds.
			while read command
			do
				echo "$here/cod-enqueue" $command
				"$here/cod-enqueue" $command
			done <"$out/ubuntu-stable/$build/REBUILD.submit"
		fi
	done
	find "$incoming/ubuntu-stable" -empty -type d -delete
fi

if [ -d "$incoming/static-analysis" ]; then
	echo "Scanning static-analysis ..."
	rsync -v -a --remove-source-files "$incoming/static-analysis/" "$out/static-analysis/"
	find "$incoming/static-analysis" -empty -type d -delete
fi

# We are done.
rm -f "$lock"

echo "$P: publishing run complete"
