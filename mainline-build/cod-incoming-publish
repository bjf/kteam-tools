#!/bin/bash
#
# cod-incoming-publish -- pull publishable images out of incoming and 
# install them, upload them, and/or announce them as required.
#
P="cod-incoming-publish"

here=`dirname $0`
case "$here" in
/*) ;;
*)  here="`pwd`/$here" ;;
esac

incoming="$HOME/incoming"
lock_tmp="$incoming/.LOCK-$$"
lock="$incoming/.LOCK"

out="$HOME/public_html"
outgoing="$HOME/public_html/mainline"

# One at a time please...
mkdir -p "$incoming"

echo "$$" >"$lock_tmp"
while ! ln "$lock_tmp" "$lock" 2>/dev/null
do
    echo "$P: incoming locked ... waiting" 1>&2
    sleep 15
done
rm -f "$lock_tmp"

# Pull out any published images ...
(cd "$incoming/mainline" && find . -name COMMIT) | \
while read commit
do
	build=`dirname "$commit"`
	build=${build#./}

	echo "$P: $build: mainline publishing ..."
	announce=-2
	if [ -d "$outgoing/$build" ]; then
		echo "$P: $build: result already published, removing previous ..."
		rm -rf "$outgoing/$build"
		announce=-1
	fi
	mkdir -p "$outgoing/`dirname "$build"`"
	mv "$incoming/mainline/$build" "$outgoing/$build" && \
	{
		# Sign the publication.
		rm -f "$outgoing/$build/CHECKSUMS.gpg"
		gpg -a -b --sign --output "$outgoing/$build/CHECKSUMS.gpg" "$outgoing/$build/CHECKSUMS"

		case "$build" in
		*/*)	;;
		*)	announce="${announce#-}" ;;
		esac
	}
	if [ "$announce" -gt 0 ]; then
		echo "$P: $build: announcing ..."
		"$here/mainline-announce" `head -1 "$outgoing/$build/COMMIT"` "$build" "$announce" "$outgoing/$build/BUILT"
	fi
done

# Look for any uploads for various PPAs.
for ppa in 'test-devel' 'pre-proposed'
do
	(
		[ ! -d "$incoming/upload/$ppa" ] && exit 0
		cd "$incoming/upload/$ppa" || exit 1
		mkdir -p failed

		for package in *_source.changes
		do
			package=${package%_source.changes}
			if [ "$package" = "*" ]; then
				continue
			fi

			echo "$P: $package: uploading ..."

			# Sign the package we are meant to be uploading.
			echo "n" | debsign -kkernel-ppa "${package}_source.changes"

			# And upload it.
			dput "$ppa" ${package}_source.changes && \
				rm -f "${package}"* || mv "${package}"* failed
		done
	)
done

# Look for any source packages for the native PPA builders.
(
	cd "$incoming/native/source" || exit 1

	for package in *_source.changes
	do
		package=${package%_source.changes}
		if [ "$package" = "*" ]; then
			continue
		fi

		echo "$P: $package: mainline-native job queueing ..."

		# Sign the package we are meant to be uploading.
		echo "n" | debsign -kkernel-ppa "${package}_source.changes"

		# Move it to the queue directory so we only queue it once.
		mkdir -p "$incoming/native/queue"
		mv -f "${package}"* "$incoming/native/queue"

		# Queue it up.
		"$here/cod-enqueue" --to mainline-native "cod-mainline-native-build" "${package}"
	done
)
# Look for any completed native builds.
(
	outgoing="$outgoing/native"

	[ ! -d "$incoming/native/publish" ] && exit 0
	mkdir -p "$incoming/native/publish"
	cd "$incoming/native/publish" || exit 1
	for prefix in *
	do
		if [ "$prefix" = "*" ]; then
			continue
		fi
		# Identify the build.
		{
			read commit
			read sha1
		} <"$prefix/COMMIT"
		build="$commit"
		
		echo "$P: $build: native build publishing ..."

		mkdir -p "$outgoing"
		if [ -d "$outgoing/$build" ]; then
			echo "$P: $build: result already published, removing previous ..."
			rm -rf "$outgoing/$build"
		fi
		mv "$prefix" "$outgoing/$build" && \
		{
			# Sign the publication.
			rm -f "$outgoing/$build/CHECKSUMS.gpg"
			gpg -a -b --sign --output "$outgoing/$build/CHECKSUMS.gpg" "$outgoing/$build/CHECKSUMS"
		}
	done
)

# Copy in incoming configuration dumps.
mkdir -p "$HOME/public_html/config"
if [ -d "$HOME/incoming/config" ]; then
	rsync -v -a --remove-source-files "$HOME/incoming/config/" "$HOME/public_html/config/"
	find "$HOME/incoming/config" -empty -type d -delete
fi


if [ -d "$HOME/incoming/test-build" ]; then
	(cd "$incoming/test-build" && find . -name SUMMARY) | \
	while read summary
	do
		build=`dirname "$summary"`
		build=${build#./}

		echo "$P: $build: test-build publishing ..."
		announce='build'
		if [ -d "$out/test-build/$build" ]; then
			echo "$P: $build: result already published, removing previous ..."
			rm -rf "$out/test-build/$build"
			announce='rebuild'
		fi
		mkdir -p "$out/test-build/`dirname "$build"`"
		mv "$incoming/test-build/$build" "$out/test-build/$build"
		echo "$P: $build: announcing ..."
		"$here/mainline-changeset-announce" "$out/test-build/$build" "$announce"
	done
	find "$HOME/incoming/test-build" -empty -type d -delete

	# Rebuild the summaries.
	(
		cd "$out/test-build" || exit 1

		for sp in */*
		do
			[ ! -d "$sp" ] && continue

			"$here/cod-changeset-summary" "$sp" >"$sp/index.html.new"
			mv -f "$sp/index.html.new" "$sp/index.html"
		done
	)
fi
# Finally re-evaluate any 'current' links.
(
	cd "$outgoing" || exit 1

	find . -name current | \
	while read current
	do
		dir=`dirname "$current"`
		latest=`ls -1 "$dir" | grep -v '^current$' | tail -1`

		is=`readlink "$current"`
		if [ "$is" != "$latest" ]; then
			echo "$P: $dir: updating current to $latest"
			rm -f "$current"
			ln -s "$latest" "$current"
		fi
	done
)
# We are done.
rm -f "$lock"

echo "$P: publishing run complete"
