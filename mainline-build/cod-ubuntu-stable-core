#!/bin/bash
P='cod-ubuntu-stable-core'

# Options.

if [ "$#" -ne 3 ]; then
	echo "Usage: $0 <series> <remote> <commit-ish>" 1>&2
	exit 1
fi

here=`dirname $0`
case "$here" in
/*) ;;
*)  here="`pwd`/$here" ;;
esac

. "$here/lib-build"
. "$here/lib-chroot"

series="$1"
remote="$2"
commit="$3"

build_release="$series"
id="$commit"

master_tree_select

result="../RESULT"
rm -rf "$result"
mkdir -p "$result"

echo "$P '$series' '$remote' '$commit'" >"$result/REBUILD"

host=$( hostname )
start_time=$( date +%s )

# Ensure we have the commit identified.
repo_remote_update_list $remote

# Make sure git is ready for anything...
rm -rf .git/rebase-apply
git reset --hard HEAD
git clean -x -f -d

# Make a branch at the specified commit.
git checkout HEAD^ --
git branch -D "tip-$id" || true
git checkout -b "tip-$id" "$commit"

# Find the commit time.
sha=$( git log -1 --pretty=format:%H "$commit" )
cts=$( git log -1 --pretty=format:%ct "$commit" )
cts="$cts"
title=$( git log -1 --pretty=format:%s "$commit" )

# Clean the tree so we can tell what architectures need building.
git clean -x -f -d
do_chroot "$build_release-amd64" \
	fakeroot debian/rules clean
archs=$(
	grep Architecture debian/control |
	awk '{ for (c=2; c <= NF; c++) { print $c } }' |
	sed -e 's/all/amd64/' |
	sort -u
)

build_archs=""
for arch in $archs
do
	case "$arch" in
	all|x32)	continue ;;
	*)		;;
	esac

	build_archs="$build_archs $arch"
done

end_time=$( date +%s )
cat - <<EOL >"$result/core.summary"
Host: $host
Series: $series
Commit: $commit
Subject: $title
Hash: $sha
Committed: $cts
Start: $start_time
Archs:$build_archs
End: $end_time
EOL

# Drop a set of messages to enqueue.
for arch in $build_archs
do
	echo "cod-ubuntu-stable-build.$arch $series $remote $commit $arch"
done >"$result/REBUILD.submit"

# Finally mark this as a partial result.
touch "$result/.result"

# Output.
publish="$HOME/public_html/ubuntu-stable/$series/$commit"
mkdir -p "$publish"
mv "$result"/* "$publish"
