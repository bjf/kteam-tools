#!/usr/bin/env python
#

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, INFO, DEBUG

from ktl.utils                          import stdo, eout, run_command
from ktl.git                            import Git, GitError
from ktl.debian                         import Debian, DebianError
from ktl.kernel                         import Kernel, KernelError
from ktl.ubuntu                         import Ubuntu
from ktl.termcolor                      import colored
from launchpadlib.launchpad		import Launchpad
import re
import ConfigParser

# AppError
#
# A general exception that can be raised when an error is encountered in the app.
#
class AppError(Exception):
    # __init__
    #
    def __init__(s, error=''):
        s.msg = error


# VerifyReleaseReady
#
class VerifyReleaseReady():
    # __init__
    #
    def __init__(s, args):
        s.args = args
        s.defaults = {}
        s.defaults['verbose'] = False
        s.passed = 0
        s.failed = 0
        s.delimiter = 40
        # add launchpadlib support
        s.lp = Launchpad.login_anonymously(s.__class__.__name__, 'production')
        s.lp_ubuntu = s.lp.distributions['ubuntu']
        s.lp_devel_series = s.lp_ubuntu.current_series

    # initialize
    #
    def initialize(s):
        validation_sequence = [
            (s.is_repo, True, 'is valid git repo'),
        ]

    # Are we currently in a git repository?
    #
    def is_repo(s):
        retval = True
        if not Git.is_repo():
            raise AppError('This script can only be run from within a git repository.')
        return retval

    # Print colorized status line
    #
    # flag:
    #   False                   -> fail (red)
    #   "warning"               -> warning (yellow)
    #   True or any other value -> pass (green)
    def status(s, msg, flag):
        indent = s.delimiter - len(msg)
        if indent <= 0:
            indent = 0

        stdo('%s' % (' ' * indent) + msg + ': ')
        if flag:
            s.passed += 1
            if flag == 'warning':
                stdo(colored('warning\n', 'yellow'))
            else:
                stdo(colored('pass\n', 'green'))
        else:
            s.failed += 1
            stdo(colored('fail\n', 'red'))

    def verbose(s, msg):
        if s.args.verbose:
            stdo(colored(msg + '\n', 'blue'))

    def verify_linux(s, cl1, cl2):
        if '-' not in cl1['version']:
            raise AppError("The version string is not well formed (missing '-').")

        (cl1_version, abi_build) = cl1['version'].split('-')  # Current version line
        cl1_abi   = cl1['ABI']
        cl1_build = cl1['upload-number']

        (cl2_version, abi_build) = cl2['version'].split('-')  # Previous version line
        cl2_abi   = cl2['ABI']
        cl2_build = cl2['upload-number']

        # Verify the version information in the changelog
        #
        while True:
            # Version is correct
            #
            msg = 'kernel version (%s)' % (Kernel.version())
            if cl1_version != Kernel.version():
                s.status(msg, False)
                s.verbose("expected '%s' but got: '%s'" % (Kernel.version(), cl1_version))
            else:
                s.status(msg, True)

            # Check: Make sure the current version is correctly incremented from the previous one.
            #
            msg = 'build number (%d)' % (int(cl2_build) + 1)
            if int(cl1_build) != int(cl2_build) + 1:
                s.status(msg, False)
                s.verbose("expected %d but got: %d" % (int(cl2_build), int(cl1_build)))
            else:
                s.status(msg, True)

            # Check: Make sure that the abi directory has the previous version
            v = cl2['version']
            if '~' in v:
                v = v.split('~', 1)[0]
            msg = 'previous abi present (%s)' % (v)
            abi = Debian.abi()
            if  v not in abi:
                s.status(msg, False)
            else:
                s.status(msg, True)

            # If ABI override is present, then check correctness and print info
            abi_arch, empty = Debian.abi_arch()
            allAbiOverridden = True
            noneAbiOverridden = True
            allModOverridden = True
            noneModOverridden = True
            for arch in abi_arch:
                if "ignore" in abi_arch[arch]:
                    noneAbiOverridden = False
                else:
                    allAbiOverridden = False
                if "ignore.modules" in abi_arch[arch]:
                    noneModOverridden = False
                else:
                    allModOverridden = False
            if noneAbiOverridden is False:
                msg = 'ABI override is present'
                s.status(msg, True)
                if allAbiOverridden is False:
                    msg = 'Not all arches have ABI overridden'
                    s.status(msg, False)
            if (noneModOverridden is False):
                msg = 'Module override is present'
                s.status(msg, True)
                if allModOverridden is False:
                    msg = 'Not all arches have Module overridden'
                    s.status(msg, False)
            if allAbiOverridden != allModOverridden:
                msg = 'Both ABI and Module override must be present'
                s.status(msg, False)
            for emptyFile in empty:
                msg = 'Empty override file: %s' % emptyFile
                s.status(msg, False)

            # Check: That the release information is correct.
            #
            ub = Ubuntu()
            series = ub.series_name(cl1['package'], cl1['version'])
            msg = 'release (%s)' % (series)
            if cl1['release'] != series:
                s.status(msg, False)
                s.verbose("expected '%s' but got: '%s'" % (Kernel.release(), cl1['release']))
            else:
                s.status(msg, True)

            break

        changelog = Debian.changelog()

        if cl1['package'] != 'linux':
            tag_prefix = 'Ubuntu-' + cl1['package'].replace('linux-', '')
        else:
            tag_prefix = 'Ubuntu'

        # Check: Make sure the commit of the version is the correct text.
        #
        log = Git.log(num=1) # Only interested in the last commit

        commit = []
        for line in log['commits'][0]['text']:
            line = line.strip()
            if line != '':
                if 'Signed-off-by' not in line:
                    commit.append(line)

        version = '%s-%s.%s' % (cl1['linux-version'], cl1['ABI'], cl1['upload-number'])

        (closed, expected_re) = s.verify_closing_commit(cl1, commit, version)

        # Construct the expected tag, and verify that it matches the
        # latest commit tag
        #
        config = ConfigParser.RawConfigParser()
        if config.read('debian/gbp.conf'):
            expect_tag_format = config.get('buildpackage', 'debian-tag')
            v = version
            # Starting with trusty, the lts backports closing commit and the tag
            # contain '~<series_version>' (e.g. '~14.04.1')
            if 'linux-lts-' in cl1['package']:
                v = cl1['version']
            expect_tag = expect_tag_format%{'version':v}
            s.verify_tag(log, expect_tag)
        else:
            s.status('missing debian/gbp.conf', 'warning')
            if closed:
                s.verify_tag(log, expected_re)

        # Look to see if a tracking bug has been added to the changelog
        #
        found_tracker = False
        for line in changelog[1]['content']:
            if found_tracker:
                if '#' in line:
                    (junk, tracker_id) = line.split('#')
                else:
                    tracker_id = 'warning'
                s.status('conformant release tracking bug line', tracker_id)
                if tracker_id == 'warning':
                    stdo(colored('\t%s\n' % line, 'yellow'))
                break
            if 'Tracking Bug' in line:
                found_tracker = True
        s.status('release tracking bug', found_tracker)

        # If we are on a topic branch make sure we are not re-using the same tracking
        # bug from as the master branch. (The master and master-next branches can have
        # the same tracking bug #)
        #
        if found_tracker and tracker_id != 'warning':
            branch = Git.current_branch()
            if branch not in ['master', 'master-next'] and not branch.endswith('-next'):
                master_changelog = Debian.master_changelog()
                found_tracker = False
                l = 0
                for line in master_changelog[1]['content']:
                    l += 1
                    if found_tracker:
                        if '#' in line:
                            (junk, master_tracker_id) = line.split('#')
                        break
                    if 'Tracking Bug' in line:
                        found_tracker = True

                unique_tracker = False
                if found_tracker:
                    if tracker_id != master_tracker_id:
                        unique_tracker = True


                s.status('unique release tracking bug', unique_tracker)

        # Verify the bugs in the changelog are public, targeted against linux and the
        # proper series, and marked Fix Committed.
        s.verify_changelog_bugs()

        s.verify_content()

    def verify_closing_commit(s, cl1, commit, version):
        # **NOTE: Because we are inconsistent with the exact text used in the last commit
        #         I'm loosing up the matching a bit but making sure that what is in the
        #         last commit matches the tag
        #
        closed = True
        expected = '^UBUNTU: (Ubuntu[-\S]*-(%s|%s))$' % (version, cl1['version'])
        m = re.match(expected, commit[0])
        msg = 'closing release commit'
        if len(commit) != 1:        # There should only be a single line in the commit
            s.status(msg, False)
            s.verbose("too many lines of text")
            closed = False
        elif m == None:
            s.status(msg, False)
            s.verbose("expected '%s', got '%s'" % (expected, commit[0]))
        else:
            expected = m.group(1) # This should be the tag text
            s.status(msg, True)

        return closed, expected

    def verify_tag(s, log, expected):
        # Check: Make sure the commit corresponds to the tag.
        #        Only runs if we have the expected tag.
        #
        # **NOTE: There can be multiple tags associated with the specific commit.
        #
        tag_found = False
        # '~' are illegal characters in tags, and shall be replaced by an '_'
        expected = expected.replace('~', '_')
        msg = 'correct tag (%s)' % expected
        s.verbose('closing commit sha1: %s' % log['commits'][0]['sha1'])
        tags = Git.tags(contains=log['commits'][0]['sha1'])
        for tag in tags:
            if tag == expected:
                s.status(msg, True)
                tag_found = True
                break
        if not tag_found:
            s.status(msg, False) # the specified commit.
            s.verbose("unable to find any tag that matched (%s) on the last commit " % (expected))
        else:
            # Verify tag has been pushed!
            msg = 'tag pushed'
            status, result = run_command("git ls-remote --tags origin %s" % expected)
            if status == 0 and expected in result[0]:
                s.status(msg, True)
            else:
                s.status(msg, 'warning')

    def verify_changelog_bugs(s):
        master_changelog = Debian.master_changelog()[1]
        changelog_bugs = master_changelog['bugs']
        changelog_series = master_changelog['series']
        changelog_source_package = master_changelog['package']

        for bug in changelog_bugs:
            # Error on private or invalid bugs
            try:
                lp_bug = s.lp.bugs[bug]
            except:
                s.status('LP: #%s: invalid/private bug number' % bug, False)
                continue

            # Ignore kernel-release-tracking-bug's
            if 'kernel-release-tracking-bug' in lp_bug.tags:
                continue

            # check bug tasks, is series/package/status correct?
            is_targeted_to_package = False
            is_targeted_to_series = False
            is_fix_committed = False
            for task in lp_bug.bug_tasks:
                task_display_name = task.bug_target_display_name.lower()
                # if the display name 'linux (ubuntu X)' matches our package continue
                if changelog_source_package in task_display_name:
                    is_targeted_to_package = True
                    # if the display name contains the series, or we are devel continue
                    if (changelog_series in task_display_name) or \
                       (changelog_series == s.lp_devel_series.displayname.lower()):
                        is_targeted_to_series = True
                        # if we are on a devel or series targeted task check status of that task
                        if task.status == u'Fix Committed':
                            is_fix_committed = True

            # display status based on results
            if not is_targeted_to_package:
                s.status('LP: #%s is not package %s' % (bug, changelog_source_package), False)
            if not is_targeted_to_series:
                s.status('LP: #%s is not series %s' % (bug, changelog_series), 'warning')
            if not is_fix_committed:
                s.status('LP: #%s is not fix committed' % bug, 'warning')

    def verify_content(s):
        changelog = Debian.changelog()

        # It's important that there be a single blank line at the beginning of
        # the content. (after the package/version/pocket line)
        #
        ei = 1
        et = []
        error_text = 'There should be one and only one blank line following the package/version/pocket line.'
        content_error = False
        test = changelog[1]['content'][0].strip()
        if test != '':                              # Should be a blank line
            s.status('content [%d]' % ei, False)
            ei += 1
            et.append(error_text)
            content_error = True

        test = changelog[1]['content'][1].strip()
        if not content_error and test == '':       # Should not be a blank line
            s.status('content [%d]' % ei, False)
            ei += 1
            et.append(error_text)
            content_error = True

        # The "Final" line in the version content should be a line that starts
        # with two dashes, has an email address and a date/time stamp.
        #
        cl = len(changelog[1]['content'])
        error_text = 'The final three lines of a new changelog block should be a blank line, a "signature" line, and a final blank line.'

        if changelog[1]['content'][cl - 3].strip() != '': # Should be a blank line
            s.status('final commit content [%d]' % ei, False)
            et.append(error_text)
            content_error = True
        else:
            if changelog[1]['content'][cl - 1].strip() != '': # Should be a blank line
                s.status('final commit content [%d]' % ei, False)
                et.append(error_text)
                content_error = True
            else:
                if changelog[1]['content'][cl - 2].strip() == '': # Should be the "signature" line
                    s.status('final commit content [%d]' % ei, False)
                    et.append(error_text)
                    content_error = True
                else:
                    m = re.match('^ -- (.*) <(.*)@(.*)> .*$', changelog[1]['content'][cl - 2])
                    if m != None:
                        if 'canonical.com' not in m.group(3):
                            error_text = "The email address on the signature line does not contail 'canonical.com'."
                            et.append(error_text)
                            s.status('final commit content [%d]' % ei, False)
                            content_error = True
                    else:
                        error_text = "Failed to parse the signature line."
                        et.append(error_text)
                        s.status('final commit content [%d]' % ei, False)
                        content_error = True

        if content_error:
            print(' ')
            ei = 1
            for e in et:
                print(' [%d] %s' % (ei, e))
                ei += 1
        else:
            s.status('final commit content', True)

    def verify_linux_meta(s, cl1, cl2):
        cl1_version = cl1['linux-version'] # Current version line
        cl1_abi   = cl1['ABI']
        cl1_build = cl1['upload-number']

        cl2_version = cl2['linux-version'] # Previous version line
        cl2_abi   = cl2['ABI']
        cl2_build = cl2['upload-number']

        while True:
            # Check: Make sure the current version is correctly incremented from the previous one.
            #
            msg = 'build number (%d)' % (int(cl2_build) + 1)
            if int(cl1_build) != int(cl2_build) + 1:
                s.status(msg, False)
                s.verbose("expected %d but got: %d" % (int(cl2_build) + 1, int(cl1_build)))
                break
            s.status(msg, True)

            break

        # Check: Make sure the commit of the version is the correct text.
        #
        log = Git.log(num=1) # Only interested in the last commit

        commit = []
        for line in log['commits'][0]['text']:
            line = line.strip()
            if line != '':
                if 'Signed-off-by' not in line:
                    commit.append(line)

        version = '%s.%s.%s' % (cl1['linux-version'], cl1['ABI'], cl1['upload-number'])
        (closed, expected) = s.verify_closing_commit(cl1, commit, version)

        if closed:
            s.verify_tag(log, expected)

        s.verify_content()

    # main
    #
    def main(s):
        kernel_packages = [
            'linux',
            'linux-ec2',
            'linux-ti-omap4',
            'linux-lts-quantal',
            'linux-lts-raring',
            'linux-lts-saucy',
            'linux-lts-trusty',
            'linux-lts-utopic',
            'linux-lts-vivid'
        ]

        non_kernel_packages = [
            'linux-ports-meta',
            'linux-signed',
            'linux-meta',
            'linux-meta-ti-omap4',
            'linux-meta-lts-raring',
            'linux-meta-lts-quantal',
            'linux-meta-lts-saucy',
            'linux-meta-lts-trusty',
            'linux-meta-lts-utopic',
            'linux-meta-lts-vivid',
            'linux-signed-lts-raring',
            'linux-signed-lts-quantal',
            'linux-signed-lts-saucy',
            'linux-signed-lts-trusty',
            'linux-signed-lts-utopic',
            'linux-signed-lts-vivid',
            'linux-backports-modules-3.5.0',
            'linux-backports-modules-3.2.0',
            'linux-backports-modules-2.6.32',
        ]

        try:
            s.initialize()

            # Check: Are we currently in a git repository?
            #
            if not Git.is_repo():
                raise AppError('This script can only be run from within a git repository.')
            s.status('is valid git repo', True)

            branch = Git.current_branch()
            s.verbose('%15s : %s' % ('branch', branch))

            changelog = Debian.changelog()

            cl1 = changelog[0]
            if s.args.verbose:
                s.verbose('\n')
                s.verbose('New version information:')
                for k in cl1:
                    s.verbose('%15s : %s' % (k, cl1[k]))

            cl2 = changelog[1]
            if s.args.verbose:
                s.verbose('\n')
                s.verbose('Previous version information:')
                for k in cl2:
                    s.verbose('%15s : %s' % (k, cl2[k]))
            if cl1['package'] in kernel_packages:
                s.verify_linux(cl1, cl2)
            elif cl1['package'] in non_kernel_packages:
                s.verify_linux_meta(cl1, cl2)
            else:
                stdo(colored('Unrecognised package: %s\n' % cl1['package'], 'yellow'))
                stdo(colored('    Trying non-kernel package verification...\n', 'yellow'))
                s.verify_linux_meta(cl1, cl2)
                stdo(colored('    Trying kernel package verification...\n', 'yellow'))
                s.verify_linux(cl1, cl2)

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle all application errors
        #
        except AppError as e:
            eout(colored(e.msg, 'red'))

        except DebianError as e:
            eout(colored(e.msg, 'red'))

        except GitError as e:
            eout(colored(e.msg, 'red'))

        except KernelError as e:
            eout(colored(e.msg, 'red'))

        return s.failed

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
I'm a application skeleton, your job is to make me into something useful.
    '''
    app_epilog = '''
examples:
    Smokem --help
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug',        action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--verbose',      action='store_true', default=False, help='Print out more an usual amount of information about what is happening.')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(levelname)s - %(message)s"
    if args.debug:
        basicConfig(level=DEBUG, format=log_format)
    else:
        basicConfig(level=INFO, format=log_format)

    app = VerifyReleaseReady(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab:
