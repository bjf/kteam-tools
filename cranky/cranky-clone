#!/usr/bin/env python3
#
# Clone the trees that make up a set of kernel packages
#
# Juerg Haefliger <juerg.haefliger@canonical.com>
#

import argparse
import logging
import os
import sys

from subprocess import call

# Add ../libs to the Python search path
sys.path.append(os.path.realpath(os.path.join(os.path.dirname(__file__), os.pardir, 'libs')))

from crl import utils
from ktl.kernel_series import KernelSeries
from ktl.log import cerror, cnotice, cwarn


def clone_repos(codename='', variant='', reference=None, dissociate=False,
                verbose=False):
    if variant == "main":
        source = "linux"
    else:
        source = "linux-%s" % variant

    cnotice("Codename: %s" % codename)
    cnotice("Variant:  %s" % variant)
    cnotice("Source:   %s" % source)

    # Parse kernel series info
    ks = KernelSeries()
    ks_series = ks.lookup_series(codename=codename)
    if ks_series is None:
        cerror("Kernel series '%s' not found" % codename)
        cnotice("Available series: %s" % ", ".join(sorted([s.codename for s in
                                                         ks.series])))
        sys.exit(1)

    ks_source = ks_series.lookup_source(source)
    if ks_source is None:
        cerror("Kernel source '%s' not found" % source)
        cnotice("Available sources: %s" % ", ".join(sorted([s.name for s in
                                                          ks_series.sources])))
        sys.exit(1)

    if len(ks_source.packages) == 0:
        cerror("No kernel packages found")

    # Cycle through the packages and clone the repos
    summary = []
    for pkg in ks_source.packages:
        repo = pkg.repo
        if repo.branch is None:
            branch = "master"
        else:
            branch = repo.branch

        # The base repo dirname, i.e., bionic/linux
        repo_dir = os.path.join(codename, "linux")

        # Append -meta or -signed to the repo dirname
        if pkg.type is not None:
            repo_dir = "%s-%s" % (repo_dir, pkg.type)

        # It's a stand-alone repo if the package is not a main package and the
        # source is either on the master or master-next branch, so append the
        # variant's name to the repo dirname
        if variant != "main" and (branch == "master" or
                                  branch == "master-next"):
            repo_dir = "%s-%s" % (repo_dir, variant)

        # Add info for the summary
        summary.append({"name": pkg.name, "dir": repo_dir, "branch": branch})

        # Skip the cloning if the target directory exists
        if os.path.exists(os.path.join(repo_dir, '.git')):
            cnotice("Directory '%s' exists already" % repo_dir)
            continue

        # Clone the repo
        cnotice("Cloning '%s' into %s" % (pkg.name, repo_dir))
        cmd = ["git", "clone", "--branch", branch]
        if pkg.type is None:
            if reference is not None:
                if ((os.path.exists(reference) and
                     os.path.exists(os.path.join(reference, '.git')))):
                    cmd.extend(["--reference", reference])
                    if dissociate:
                        cmd.extend(["--dissociate"])
                else:
                    cwarn('Warning: %s is not a directory or git repo' %
                          reference)
        cmd.extend([repo.url, repo_dir])
        if verbose:
            cnotice("Calling: %s" % " ".join(cmd))
        call(cmd)

        # Set some sensible config defaults for git send-email:
        #   - Add the Ubuntu kernel mailing list as the default 'to' email
        #     address
        #   - Don't cc the patch author and signers (we don't want to
        #     spam upstream people)
        call(["git", "config", "--local", "sendemail.to",
              "kernel-team@lists.ubuntu.com"], cwd=repo_dir)
        call(["git", "config", "--local", "sendemail.suppresscc", "all"],
             cwd=repo_dir)

        # Add a remote for the (private) security repo
        if pkg.type is None:
            security_repo = "linux-%s" % codename
        else:
            security_repo = "linux-%s-%s" % (pkg.type, codename)
        call(["git", "remote", "add", "security",
              "git+ssh://git.launchpad.net/~canonical-kernel-security-team/canonical-kernel-private/+git/%s" % security_repo],
             cwd=repo_dir)

    # Print the summary
    cnotice("Summary:")
    for s in summary:
        cnotice("  Repo '%(name)s' in directory '%(dir)s' "
              "(branch '%(branch)s')" % s)


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format="%(message)s")

    # Get the config options from file
    config = utils.get_config(tool='clone')

    desc = """
Clone the repos (typically 'linux', 'linux-meta', and 'linux-signed') that make
up a set of Ubuntu kernel packages.
"""

    epilog = """
Examples:
  $ cranky-clone xenial
      The 'linux', 'linux-meta' and 'linux-signed' repositories for Xenial
      are all cloned under a 'xenial' root directory:
        ./xenial/
          ├── linux
          ├── linux-meta
          └── linux-signed

  $ cranky-clone --reference /home/work/linux-2.6 xenial main
      Same as above but use a local clone of Linus' upstream repo as a git
      reference.

  $ cranky-clone xenial aws
      The 'linux-aws', 'linux-meta-aws' and 'linux-signed-aws' repositories for
      the Xenial AWS variant are cloned under a 'xenial' root directory:
        ./xenial/
          ├── linux-aws
          ├── linux-meta-aws
          └── linux-signed-aws

  $ cranky-clone xenial raspi2
      This variant doesn't have stand-alone repos but instead resides on
      branches of the main 'linux', 'linux-meta' and 'linux-signed' repos. See
      below for more details.

Notes:
  Some kernel variants have their own repos (like aws, for example) whereas
  others simply reside on branches of the main repos (like raspi2). If a
  stand-alone variant is cloned, the repos end up in their own subdirectories
  (see the aws example above). Cloning a non stand-alone variant simply results
  in cloning the main repos (if they aren't already locally present). At the
  end of the operation, the tool will print out the directory and branch names
  for the clones.

Configuration file:
  ~/.cranky is a yaml format configuration file where the optional commandline
  options can be specified. Note that options specified via the commandline
  take precedence over options from the configuration file.

  Example ~/.cranky section:
  ---
    clone:
      reference: '/home/repo/linux-2.6'
      dissociate: true
"""

    help_variant = """
Kernel variant (main, raspi2, aws, ...). If not specified, defaults to 'main',
which is the main distro kernel for the specified series.
"""

    help_reference = """
Obtain objects from an existing local repository to speed up the cloning
process. This is a git clone option, check 'git help clone' for more details.
Note that without using --dissociate, the referenced repo *must not* be deleted
otherwise the cranky-cloned repo will get corrupted.
"""

    help_dissociate = """
Borrow the objects from the referenced local repository only to reduce network
traffic. This is a git clone option, check 'git help clone' for more details.
"""

    parser = argparse.ArgumentParser(description=desc, formatter_class=
                                     argparse.RawDescriptionHelpFormatter,
                                     epilog=epilog)
    parser.add_argument("codename", help="Kernel series codename (artful, "
                        "bionic, ...)")
    parser.add_argument("variant", nargs="?", default="main",
                        help=help_variant)
    parser.add_argument("-v", "--verbose", action="store_true",
                        default=config.get('verbose', False),
                        help="Increase verbosity")
    parser.add_argument("-r", "--reference",
                        default=config.get('reference', None),
                        help=help_reference)
    parser.add_argument("-d", "--dissociate", action="store_true",
                        default=config.get('dissociate', False),
                        help=help_dissociate)

    clone_repos(**vars(parser.parse_args()))
