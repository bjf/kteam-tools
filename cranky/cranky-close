#!/usr/bin/python3

import os
import sys

# Add ../libs to the Python search path
sys.path.append(os.path.realpath(os.path.join(os.path.dirname(__file__), os.pardir, 'libs')))

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, DEBUG, INFO, WARNING
from ktl.git                            import Git
from ktl.debian                         import Debian
from ktl.log                            import Clog
from ktl.utils                          import run_command

# AppError
#
# A general exception that can be raised when an error is encountered in the app.
#
class AppError(Exception):
    # __init__
    #
    def __init__(self, error=''):
        self.msg = error

class Close():
    def __init__(s, dryrun=False, master_branch="master-next", config=False):
        s.master_branch = master_branch
        s.dryrun = dryrun
        s.config = config

    def is_config_changed(s):
        """
        Check if debian.{master,derivative}/config/ has changed from HEAD.
        """
        (status, output) = run_command('git diff HEAD %s/config/' % (s.debiandir))
        output = list(filter(None, output))
        if len(output) > 0:
            return 1
        return status

    def master_version_from_changelog(s):
        for c in s.changelog:
            if c.get('master'):
                return c['master']
        return None

    def series_from_changelog(s):
        for c in s.changelog:
            if c.get('series') and c['series'] != 'UNRELEASED':
                return c['series']
        return None

    def commit(s):
        if s.branch == "master":
            s.prefix = "Ubuntu-"
        else:
            s.prefix = "Ubuntu-{}-".format(s.branch)
        s.version = s.changelog[0]['version']
        cmd = "git commit -sam 'UBUNTU: {}'".format(s.prefix + s.version)
        run_command(cmd, s.dryrun)

    def link_to_tracker(s):
        # TODO: should be implemented, challenge: allow for a rerun
        print("You should call link-to-tracker and ammend\n")

    def tag(s):
        s.version2 = s.version.replace("~", "_")
        print("git tag -sm '{}' '{}'".format(s.prefix + s.version, s.prefix + s.version2))

    def main(s):
        retval = 1
        s.debiandir = Debian.debian_env()
        (_tmp, s.branch) = s.debiandir.split(".", 1)
        s.changelog = Debian.changelog()
        master_commit = Git.ubuntu_commit(s.master_branch)
        master_version = Git.version_from_subject(master_commit)
        series = s.series_from_changelog()

        if not s.dryrun:
            Debian.fdr("clean")
            Debian.fdr("updateconfigs")
        if not s.config and s.is_config_changed():
            print("config has changed! please, review it and commit\n")
            raise AppError("config has changed! please, review it and commit\n")

        if s.branch != "master":
            base_version = s.master_version_from_changelog()
            if not base_version:
                print("No base_version found on {}/changelog".format(s.debiandir))
                return 1

            cmd = './debian/scripts/misc/insert-ubuntu-changes {}/changelog {} {}'.format(s.debiandir, base_version, master_version)
            if s.dryrun:
                print(cmd)
            else:
                os.system(cmd)

        if not s.dryrun:
            Debian.fdr("insertchanges")
            Debian.dch(series)
        s.link_to_tracker()
        s.commit()
        s.tag()
        retval = 0
        return retval

if __name__ == '__main__':
    app_description = '''
Finalizes a tree, creating the top commit that updates the changelog and any other files needed.
Besides updating the changelog, it verifies there are no needed config changes that need to be reviewed.
Use --config if you have reviewed the changes are safe to be included in the closing commit with no other explanation.
    '''

    app_epilog = '''
    '''

    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--info',  action='store_true', default=False, help='output info level logs')
    parser.add_argument('--debug', action='store_true', default=False, help='output debug level logs')
    parser.add_argument('--dry-run', action='store_true', default=False, help='do not execute, just tell what would be done')
    parser.add_argument('--master-branch', action='store', required=False, default='master-next', help='use a different master branch to rebase to')
    parser.add_argument('--config', action='store_true', required=False, help='include config changes in the closing commit')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    Clog.color = True
    if args.debug:
        log_format = "%(levelname)s - %(message)s"
        basicConfig(level=DEBUG, format=log_format)
        Clog.dbg = True
    elif args.info:
        log_format = "%(message)s"
        basicConfig(level=INFO, format=log_format)
    else:
        log_format = "%(message)s"
        basicConfig(level=WARNING, format=log_format)

    retval = 1
    try:
        retval = Close(dryrun=args.dry_run, master_branch=args.master_branch, config=args.config).main()
    except KeyboardInterrupt:
        print("Aborting ...")

    if retval > 0:
        print("")
        print("Due to the above error(s), this script is unable to continue and is terminating.")
        print("")

    exit(retval)

# vi:set ts=4 sw=4 expandtab syntax=python:
