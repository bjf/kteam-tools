#!/usr/bin/python3

import os
import sys
import argparse
import yaml
import subprocess
import re
import logging

# Add ../libs to the Python search path
sys.path.append(os.path.realpath(os.path.join(os.path.dirname(__file__), os.pardir, 'libs')))

from ktl.kernel_series import KernelSeries
from ktl.log import cerror, cwarn, cinfo

class UpdateSnap():
    def __init__(self, pocket='proposed', no_tag=False, dry_run=False):
        self.ks = KernelSeries()
        self.scy_file_name = "snapcraft.yaml"
        self.no_tag = no_tag
        self.dry_run = dry_run
        self.scy = None
        self.pocket = pocket

        self.name = None
        self.series = None
        self.source = None

        # open and parse the local snapcraft.yaml file
        try:
            with open(self.scy_file_name, 'r') as scy_file:
                self.scy = yaml.safe_load(scy_file)
        except:
            cerror("ERROR: Could not open and parse file {}".format(self.scy_file_name))
            sys.exit(1)

        # Pull out the name name.
        self.name = self.scy['name']

        # Lookup the KERNEL_SOURCE identifier.  This is either a source handle
        # (bionic:linux) or just a source package name (linux-raspi2).
        source_handle = None
        for param in self.scy['parts']['kernel']['make-parameters']:
            if param.startswith('KERNEL_SOURCE='):
                source_handle = param.split('=', 1)[1]
                break

        # <series>:<source> handle.
        if source_handle is not None and ':' in source_handle:
            (self.series, self.source) = source_handle.split(':', 1)

        # <source> plain source package.
        elif source_handle is not None:
            self.source = source_handle

        # If we have not been given a series yet, try and intuit it from the
        # source git URL /+git/<series> data.
        if self.series is None:
            self.series = self.scy['parts']['kernel']['source'].rpartition('/')[2]

        # VALIDATION: confirm series.
        ks_series = self.ks.lookup_series(codename=self.series)
        if ks_series is None:
            cerror("ERROR: {} invalid series specified".format(self.series))
            sys.exit(1)

        # If we have no source yet, find it using the series and snap name.
        if self.source is None:
            for source in ks_series.sources:
                copy_forward = source.copy_forward
                if copy_forward is not None:
                    source = copy_forward
                snap = source.lookup_snap(self.name)
                if snap is not None:
                    self.source = source.name
                    break
            if self.source is None:
                cerror("ERROR: {} snap not found in {}".format(self.name, self.series))
                sys.exit(1)

        # VALIDATION: confirm source.
        ks_source = ks_series.lookup_source(self.source)
        if ks_source is None:
            cerror("ERROR: {} source not found in {}".format(self.source, self.series))
            sys.exit(1)

        # VALIDATION: confirm snap.
        copy_forward = ks_source.copy_forward
        if copy_forward is not None:
            ks_source = copy_forward
        self.snap = ks_source.lookup_snap(self.name)
        if self.snap is None:
            cerror("ERROR: {} snap not found on {}:{}".format(self.name, self.series, self.source))
            sys.exit(1)

        # Record the series in which we should look for the version.
        self.series_version = ks_source.series.codename

    def get_published_ver(self, pkg_name, series, pocket):
        '''
        Use 'rmadison' to get the package version published for the given
        series/pocket.
        '''
        suite = series
        if pocket != 'release':
            suite += '-' + pocket
        ret = subprocess.check_output(['rmadison', '-a', 'source', '-s', suite, pkg_name])
        if not ret:
            cerror("ERROR: No version available in {}".format(suite))
            sys.exit(1)

        return ret.decode().strip().split('|')[1].strip()

    def update_snap(self, version, url):
        '''
        Update the snapcraft yaml file with the new version.
        '''
        with open(self.scy_file_name, 'r') as scy_file:
            scy_content = scy_file.read()

        if self.scy['version'] != version:
            scy_content = re.sub(r'version: .*', 'version: {}'.format(version), scy_content)
            cinfo("INFO: update version from %s to %s" %
                  (self.scy['version'], version))
        if self.scy['parts']['kernel']['source'] != self.snap.repo.url:
            scy_content = re.sub(r'( *source: ) *{}'.format(
                re.escape(self.scy['parts']['kernel']['source'])),
                r'\1{}'.format(url), scy_content)
            cinfo("INFO: update url:\n      %s\n      %s" %
                  (self.scy['parts']['kernel']['source'], self.snap.repo.url))

        if not self.dry_run:
            with open(self.scy_file_name, 'w') as scy_file:
                scy_file.write(scy_content)

    def get_commit_subject(self, version):
        '''
        Return a string with the subject to be used for the commit,
        based on the previous commit messages.
        '''
        cmd = "git log --pretty=%%s -1 --grep='UBUNTU: Ubuntu-.*[0-9]'  -- %s" % self.scy_file_name
        last_commit = subprocess.check_output(cmd, shell=True).decode()

        match = re.match(r'(UBUNTU: Ubuntu-)(([a-z][^-]*-)*)[0-9].*', last_commit)
        prefix = match.group(1)
        flavour = match.group(2)

        return "%s%s%s" % (prefix, flavour, version)

    def get_tag_from_commit(self, subject):
        '''
        Given a commit subject, return a tuple with the tag name and tag msg to
        be used for that commit.
        '''
        tag_msg = re.sub(r'^UBUNTU: ', '', subject)
        tag_name = tag_msg.replace('~', '_')

        return (tag_name, tag_msg)

    def main(self):
        '''
        main method.
        '''
        proposed_ver = self.get_published_ver(self.source, self.series_version, self.pocket)
        if (self.scy['version'] == proposed_ver and
                self.scy['parts']['kernel']['source'] == self.snap.repo.url):
            cerror("ERROR: No new version available in -{}".format(self.pocket))
            sys.exit(1)

        self.update_snap(proposed_ver, self.snap.repo.url)
        commit_msg = self.get_commit_subject(proposed_ver)
        (tag_name, tag_msg) = self.get_tag_from_commit(commit_msg)
        commit_cmd = "git commit -s -m '%s' -- %s" % (commit_msg, self.scy_file_name)
        tag_cmd = "git tag -sm '%s' '%s'" % (tag_msg, tag_name)
        if not self.dry_run:
            ret = subprocess.call(commit_cmd, shell=True)
            if ret != 0:
                cerror("ERROR: Failed to commit. Return code: %d", ret)
                sys.exit(1)

            if self.no_tag:
                cinfo("Please review and tag:")
                cinfo(tag_cmd)
            else:
                cinfo("INFO: Running: %s" % tag_cmd)
                ret = subprocess.call(tag_cmd, shell=True)
                if ret != 0:
                    cerror("ERROR: Failed to tag commit. Return code: %d" % ret)
                    sys.exit(1)
        else:
            cinfo("INFO: Dry run: would run:")
            cinfo("%s" % commit_cmd)
            cinfo("%s" % tag_cmd)


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO, format="%(message)s")

    desc = """
Update the kernel snap snapcrat.yaml file with the source package version
published on the specified pocket (default from -proposed).
"""

    epilog = """
Examples:
    $ cranky-update-snap
        Get source package version from -proposed and automatically tag.

    $ cranky-update-snap --updates
        Get source package version from -updates and automatically tag.

    $ cranky-update-snap --no-tag
        Get source package version from -proposed and don't tag, showing only
        the 'git tag' command to be run.
"""

    parser = argparse.ArgumentParser(description=desc, epilog=epilog,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("--dry-run", action="store_true", default=False,
                        help="do not make any changes, just show what would be done")
    parser.add_argument("-r", "--release", action="store_true", default=False,
                        help="get version from -release instead of -proposed")
    parser.add_argument("-u", "--updates", action="store_true", default=False,
                        help="get version from -updates instead of -proposed")
    parser.add_argument("-t", "--no-tag", action="store_true", default=False,
                        help="do not automatically tag the commit")
    args = parser.parse_args()

    pocket = 'proposed'
    if args.updates:
        pocket = 'updates'
    if args.release:
        pocket = 'release'
    update_snap = UpdateSnap(pocket, args.no_tag, args.dry_run)
    update_snap.main()
