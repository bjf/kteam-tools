#!/usr/bin/python3

import os
import sys
import re

# Add ../libs to the Python search path
sys.path.append(os.path.realpath(os.path.join(os.path.dirname(__file__), os.pardir, 'libs')))

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, DEBUG, INFO, WARNING
from ktl.log                            import Clog
from ktl.git                            import Git
from ktl.shell                          import ShellError
from ktl.utils                          import run_command
from ktl.debian                         import Debian

class Rebase():
    def __init__(s, dryrun=False, master_branch=None):
        s.master_branch = master_branch
        s.dryrun = dryrun
        source = Debian.get_source_from_kernel_series()
        s.base_source = source.derived_from

    def main(s):
        # Get the current release commit which this kernel is based on
        if not s.base_source:
            print("Base kernel is unknown. Please check the kernel-series.yaml file.")
            return 1
        base_name = re.sub("^linux-?", "", s.base_source.name)
        if not base_name:
            base_name = "master"
        debian_dir = "debian.%s/" % base_name
        base_commit = Git.ubuntu_commit("HEAD",
                                        include_derivatives=True,
                                        debian_dir=debian_dir)

        # Get the latest release commit of the base kernel
        if not s.master_branch:
            repo = str(s.base_source.packages[0].repo)
            if not repo:
                print("not a derived kernel, no rebase needed")
                return 0
            run_command("git fetch " + repo)
            s.master_branch = "FETCH_HEAD"
        master_commit = Git.ubuntu_commit(s.master_branch,
                                          include_derivatives=True,
                                          debian_dir=debian_dir)
        if base_commit == None:
            print("base Ubuntu commit not found, is this an Ubuntu tree?")
            return 1

        # Check if it's up to date
        master_version = Git.version_from_subject(master_commit)
        base_version = Git.version_from_subject(base_commit)
        if master_commit == base_commit:
            print("tree is already based on top of %s (%s)" % (master_version, master_commit))
            return 0

        # Rebase
        cmd = "git rebase --onto %s %s" % (master_commit, base_commit)
        print("Rebase still needed between %s and %s." % (base_version, master_version))
        (retval, output) = run_command(cmd, dry_run=s.dryrun)
        if retval:
            print("Failed to rebase.")
            print("\n".join(output))
        return retval


if __name__ == '__main__':
    app_description = '''
Rebase the current branch to the master-next branch (or the branch
specified by the --master-branch option).
    '''

    app_epilog = '''
The rebase is, in fact, on top the last closing Ubuntu commit from the
master branch, and using as upstream the last closing Ubuntu commit from
the current branch.

For instance, take the following repository:

        o---o master-next
        /
o---o---o Ubuntu-4.4.0-100.100
o---o Ubuntu-4.4.0-99.99
    \\
    o---o raspi2

The rebase will be like, independently on whether Ubuntu-4.4.0-99.99 is an
ancestor to Ubuntu-4.4.0-100.100 or not:

        o---o master-next
        /
o---o---o Ubuntu-4.4.0-100.100
        \\
        o'---o' raspi2
    '''

    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--info',  action='store_true', default=False, help='output info level logs')
    parser.add_argument('--debug', action='store_true', default=False, help='output debug level logs')
    parser.add_argument('--dry-run', action='store_true', default=False, help='do not execute, just tell what would be done')
    parser.add_argument('--master-branch', action='store', required=False, default=None, help='use a different master branch to rebase to')
    args = parser.parse_args()

    # If logging parameters were set on the command line, handle them
    # here.
    #
    Clog.color = True
    if args.debug:
        log_format = "%(levelname)s - %(message)s"
        basicConfig(level=DEBUG, format=log_format)
        Clog.dbg = True
    elif args.info:
        log_format = "%(message)s"
        basicConfig(level=INFO, format=log_format)
    else:
        log_format = "%(message)s"
        basicConfig(level=WARNING, format=log_format)

    retval = 1
    try:
        retval = Rebase(dryrun=args.dry_run, master_branch=args.master_branch).main()
    except KeyboardInterrupt:
        print("Aborting ...")

    if retval:
        print("")
        print("Due to the above error(s), this script is unable to continue and is terminating.")
        print("")

    exit(retval)

# vi:set ts=4 sw=4 expandtab syntax=python:
