#!/usr/bin/env python
#

from sys                                import argv
from os                                 import path
from getopt                             import getopt, GetoptError
import json
from ktl.utils                          import stdo, error
from ktl.std_app                        import StdApp
from lpltk.LaunchpadService             import LaunchpadService

# CmdlineError
#
# The type of exception that will be raised by Cmdline.process() if there
# are command line processing errors.
#
class CmdlineError(Exception):
    # __init__
    #
    def __init__(self, error):
        self.msg = error

# Cmdline
#
# Do all the command line processing.
#
class Cmdline:
    # __init__
    #
    def __init__(self):
        self.cfg = {}

    # error
    #
    def error(self, e, defaults):
        if e != '': error(e)
        self.usage(defaults)

    # usage
    #
    # Prints out the help text which explains the command line options.
    #
    def usage(self, defaults):
        stdo("                                                                                             \n")
        stdo(" %s is a tool for taking a list of bugs and modifying them as part of the stable kernel      \n" % self.cfg['app_name'])
        stdo(" release cadence. The following changes will be made to the bugs:                            \n")
        stdo("                                                                                             \n")
        stdo("     1. A comment will be added asking that the bug be verified as having been fixed in      \n")
        stdo("        the kernel the is currently in -proposed.                                            \n")
        stdo("                                                                                             \n")
        stdo("     2. Tags will be added signifying that testing needs to be done.                         \n")
        stdo("                                                                                             \n")
        stdo("                                                                                             \n")
        stdo(" Usage:                                                                                      \n")
        stdo("     %s <options> <srus.json>                                                                \n" % self.cfg['app_name'])
        stdo("                                                                                             \n")
        stdo(" Options:                                                                                    \n")
        stdo("     --help           Prints this text.                                                      \n")
        stdo("                                                                                             \n")
        stdo("     --verbose        Give some feedback of what is happening while the script is            \n")
        stdo("                      running.                                                               \n")
        stdo("                                                                                             \n")
        #stdo("     --config=<cfg file>                                                                     \n")
        #stdo("                      The full path to the configuration file to use instead of              \n")
        #stdo("                      the default location.                                                  \n")
        #stdo("                                                                                             \n")
        #stdo("     --debug=<debug options>                                                                 \n")
        #stdo("                      Performs additional output related to the option enabled and           \n")
        #stdo("                      the application defined support for the option.                        \n")
        #stdo("                                                                                             \n")
        stdo("     --series=<rls>   Specifies for which series the version is to be returned.              \n")
        stdo("                      At this time, dapper, hardy, karmic, lucid and maverick are            \n")
        stdo("                      valid series.                                                          \n")
        stdo("                                                                                             \n")
        stdo("     --package=<pkg>  Specifies for which package the version is to be returned.             \n")
        stdo("                      Most likely a value of linux or linux-meta.                            \n")
        stdo("                                                                                             \n")
        stdo("     --comment=<file>                                                                        \n")
        stdo("                      Text is read from the indicated file and added to each bug as a        \n")
        stdo("                      new comment.                                                           \n")
        stdo("                                                                                             \n")
        stdo("     --dryrun                                                                                \n")
        stdo("                      Don't commit the changes to the bug.                                   \n")
        stdo("                                                                                             \n")
        stdo(" Examples:                                                                                   \n")
        stdo("     %s --verbose                                                                            \n" % self.cfg['app_name'])
        stdo("     %s --series=hardy --package=linux                                                       \n" % self.cfg['app_name'])
        stdo("     %s --comment=boilerplate/bugtext-start-verification.txt --package=linux --series=raring srus.json\n" % self.cfg['app_name'])

    # process
    #
    # As you can probably tell from the name, this method is responsible
    # for calling the getopt function to process the command line. All
    # parameters are processed into class variables for use by other
    # methods.
    #
    def process(self, argv, defaults):
        self.cfg['app_name'] = argv[0]
        result = True
        try:
            optsShort = ''
            #optsLong  = ['help', 'verbose', 'config=', 'debug=', 'series=', 'package=', 'comment=', 'status=']
            optsLong  = ['help', 'verbose', 'series=', 'package=', 'comment=', 'status=', 'dryrun']
            opts, args = getopt(argv[1:], optsShort, optsLong)

            for opt, val in opts:
                if (opt == '--help'):
                    raise CmdlineError('')

                elif (opt == '--verbose'):
                    self.cfg['verbose'] = True

                elif (opt == '--dryrun'):
                    self.cfg['dryrun'] = True

                #elif opt in ('--config'):
                #    self.cfg['configuration_file'] = val

                elif opt in ('--debug'):
                    self.cfg['debug'] = val.split(',')

                elif opt in ('--series'):
                    self.cfg['series'] = val

                elif opt in ('--package'):
                    self.cfg['package'] = val

                elif opt in ('--comment'):
                    self.cfg['comment'] = val

                elif opt in ('--status'):
                    self.cfg['status'] = val.strip()

            if result: # No errors yet

                # At lease one source package must be specified.
                #
                if len(args) > 0:
                    self.cfg['sru'] = args[0]

        except GetoptError, error:
            print(error, defaults)
            raise CmdlineError('')

        return self.cfg

    # verify_options
    #
    def verify_options(self, cfg):
        if ('series' not in self.cfg) or ('package' not in self.cfg):
            raise CmdlineError('--release and --package are required command line parameters.')

        if 'sru' not in self.cfg:
            raise CmdlineError('A json file containing the sru information is required. This is generated by the sru-report script.')

        if 'comment' not in self.cfg:
            raise CmdlineError('A comment file name is required.')
        return


# SpamProposedReleaseBugs
#
class SpamProposedReleaseBugs(StdApp):
    # __init__
    #
    def __init__(self):
        StdApp.__init__(self)
        self.defaults = {}
        self.defaults['dryrun'] = False

    # initialize
    #
    def initialize(self):
        self.dbg('core', "initialize: enter\n")

        self.cfg['launchpad_client_name'] = 'kernel-team-spam-proposed-release-bugs'
        self.service = LaunchpadService(self.cfg)

        # If a comment is to be added to the bug, read the comment file into a buffer
        # so we have it ready when we need it.
        #
        if 'comment' in self.cfg:
            with open(self.cfg['comment'], 'r') as f:
                self.cfg['comment-text'] = f.read()

        self.dbg('core', "initialize: leave\n")
        return

    def print_bug_info(self, bug_id, bug):
        bug_link = 'https://bugs.launchpad.net/bugs/%s' % bug_id
        self.verbose("%s    %40s    %s\n" % (bug_id, bug_link, bug.title))

    # modify_bug_status
    #
    # Change the bugs status.
    #
    def modify_bug_status(self, bug):
        tasks = bug.tasks
        if len(tasks) == 1:
            self.verbose('        . changing status to: %s'(self.cfg['status']))
            #task = tasks[0]
            #tasks[0].status = self.cfg['status']
        else:
            print("   ** Warning: This bug contains multiple bug tasks, not able to set the status.")

    # main
    #
    def main(self):
        cmdline = Cmdline()
        try:
            self.merge_config_options(self.defaults, cmdline.process(argv, self.defaults))
            cmdline.verify_options(self.cfg)

            self.initialize()

            # Pull in the sru-data.json file for use.
            #
            if path.exists(self.cfg['sru']):
                with open(self.cfg['sru'], 'r') as f:
                    sru = json.load(f)


            # Find the bugs in the specified release and package that need spamming.
            #
            series = self.cfg['series']
            package = self.cfg['package']
            try:
                pkgrec = sru['releases'][series][package]
            except:
                print("E: %s/%s: no such series/package" % (series,package))
                return
            try:
                bugs = sru['releases'][series][package]['bugs']
            except:
                self.verbose("  . %s/%s has no SRU bugs\n" % (series,package))
                return
            self.verbose("%s/%s:\n" % (series,package))
            for bug_id in bugs:
                bug = self.service.get_bug(bug_id)
                self.print_bug_info(bug_id, bug)
                should_be_spammed = False
                is_tracker_bug    = True

                # RULE: Do not add verification tags or comments to bugs that exist
                #       as "tracking" bugs.
                #
                while (True):
                    if 'kernel-cve-tracker' in bug.tags:
                        self.verbose('    . has kernel-cve-tracker tag\n')
                        break # This is a bug used to track a CVE patch

                    if 'kernel-cve-tracking-bug' in bug.tags:
                        self.verbose('    . has kernel-cve-tracking-bug tag\n')
                        break # This is a bug used to track a CVE patch

                    if 'kernel-release-tracker' in bug.tags:
                        self.verbose('    . has kernel-release-tracker tag\n')
                        break # This is a bug used to track the status of a particular release

                    if 'kernel-release-tracking-bug' in bug.tags:
                        self.verbose('    . has kernel-release-tracking-bug tag\n')
                        break # This is a bug used to track the status of a particular release

                    if 'kernel-tracking-bug' in bug.tags:
                        self.verbose('    . has kernel-tracking-bug tag\n')
                        break # Old tag that was previously used for this.

                    if 'kernel-stable-tracking-bug' in bug.tags:
                        self.verbose('    . has kernel-stable-tracking-bug tag\n')
                        break # Old tag that was previously used for this.

                    self.verbose('    . no tracking tags\n')
                    is_tracker_bug = False
                    break

                # RULE: If a bug already has the appropriate verification tags on
                #       it, we don't add them again.
                #
                while (not is_tracker_bug):
                    if 'verification-failed-%s' % self.cfg['series'] in bug.tags:
                        self.verbose('    . has verification-failed-%s tag\n' % self.cfg['series'])
                        break  # The tag exists

                    if 'verification-reverted-%s' % self.cfg['series'] in bug.tags:
                        self.verbose('    . has verification-reverted-%s tag\n' % self.cfg['series'])
                        break  # The tag exists

                    if 'verification-needed-%s' % self.cfg['series'] in bug.tags:
                        self.verbose('    . has verification-needed-%s tag\n' % self.cfg['series'])
                        break  # The tag exists

                    if 'verification-done-%s'   % self.cfg['series'] in bug.tags:
                        self.verbose('    . has verification-done-%s tag\n' % self.cfg['series'])
                        break  # The tag exists

                    # None of the tags that we are checking for exist, lets hook em up.
                    #
                    self.verbose('    . no verification tags\n')
                    should_be_spammed = True
                    break

                if should_be_spammed:
                    self.verbose('    . should be spammed\n')

                    # Tags
                    #
                    self.verbose('        . adding tag: verification-needed-%s\n' % (self.cfg['series']))
                    if not self.cfg['dryrun']:
                        bug.tags.append('verification-needed-%s' % self.cfg['series'])

                    # Comment
                    #
                    if 'comment-text' in self.cfg:
                        self.verbose('        . adding comment\n')
                        if not self.cfg['dryrun']:
                            bug.add_comment(self.cfg['comment-text'].replace('_SERIES_', self.cfg['series']))

                    # Status
                    #
                    if 'status' in self.cfg:
                        tasks = bug.tasks
                        if len(tasks) == 1:
                            self.verbose('        . changing status to: %s\n'(self.cfg['status']))
                            task = tasks[0]
                            if not self.cfg['dryrun']:
                                tasks[0].status = self.cfg['status']
                        else:
                            print("   ** Warning: This bug contains multiple bug tasks, not able to set the status.")

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            pass

        # Handle ommand line errors.
        #
        except CmdlineError as e:
            cmdline.error(e.msg, self.defaults)

        return

if __name__ == '__main__':
    app = SpamProposedReleaseBugs()
    app.main()

# vi:set ts=4 sw=4 expandtab:

