#!/usr/bin/env python3
#
# SWM - SRU Workflow Manager  (aka: shankbot)
#
# swm-publishing -- monitor publishing of things.
#

import os
import sys
from datetime import datetime, timezone
from subprocess import Popen
#from logging import DEBUG, INFO, WARNING, basicConfig

import yaml
from lazr.restfulclient.errors import Unauthorized

# Add ../libs to the Python search path
sys.path.append(os.path.realpath(os.path.join(os.path.dirname(__file__), os.pardir, 'libs')))

from ktl.kernel_series import KernelSeries
from wfl.launchpad import Launchpad
#from wfl.log import Clog, cdebug, center, cleave


class MonitorIncompatible(Exception):
    pass


class MonitorStore:
    '''
    A backing store provider for monitor data.  This class behaves very like a
    persistent dictionary.  On instantiation it will load up the specified
    yaml file.  When the sync is called all current data is flushed back
    to the backing store.  Handles timezones being lost in the default
    yaml date format.
    '''
    def __init__(self, store_path=None):
        if store_path is None:
            store_path = 'swm-publisher.yaml'

        self.store_path = store_path
        self._store = {}
        if os.path.exists(store_path):
            with open(store_path) as rfd:
                self._store = yaml.safe_load(rfd)
                self.fix_timezones(self._store)

    # YAML saves timestamps always converted to UTC and the loses
    # this information on load dispite storing +00:00 as the data.
    # As we know they are all converted to UTC we can simply wack
    # over them with a UTC timezone.
    def fix_timezones(self, record):
        for item, item_data in record.items():
            if isinstance(item_data, datetime):
                record[item] = item_data.replace(tzinfo=timezone.utc)
            elif isinstance(item_data, dict):
                self.fix_timezones(item_data)

    def __getitem__(self, key):
        return self._store[key]

    def __setitem__(self, key, value):
        self._store[key] = value

    def setdefault(self, key, value=None):
        return self._store.setdefault(key, value)

    def sync(self):
        with open(self.store_path + '.new', 'w') as wfd:
            yaml.dump(self._store, wfd, default_flow_style=False)
        os.rename(self.store_path + '.new', self.store_path)


class MonitorStoreAttr:
    '''
    This class is a Python descriptor class.  This means that an instance
    of this class may be used to replace a class attribute; all access to that
    attribute is mediated by this class.  The attribute key in the store
    is passed to the constructor, and this key is used gainst the owning
    objects _store attribute.  Typically this would be initialised to a
    unique key in the MonitorStore object.  Doing this renders the contents
    of this attribute persistent.

    For example:

        class MonitorThing:

            def __init__(self, backing_store):
                # Create a unique space in the backing store if not present.
                self._store = backing_store.setdefault('unique-key', {})
                # Default our last-date to UTC now if not present.
                self._store.setdefault('last-date', datetime.now(timezone.utc))

            # Connect the instance attribute to the backing store.
            last_date = MonitorStoreAttr('last-date')

            def operation(self, when):
                # Read and update attribute as normal.
                if self.last_date < when:
                    self.last_date = when
    '''
    def __init__(self, attr):
        self.attr = attr

    def __get__(self, obj, type=None):
        #print("__get__", self.attr, obj, type)
        return obj._store[self.attr]

    def __set__(self, obj, value):
        #print("__set__", self.attr, obj, value)
        obj._store[self.attr] = value


class MonitorLaunchpadArchive:

    def __init__(self, archive, lp=None, ks=None, bs=None):
        if lp is None:
            lp = Launchpad(False).default_service.launchpad
        if ks is None:
            ks = KernelSeries()
        if bs is None:
            bs = {}

        self._store = bs.setdefault(
            self.__class__.__name__ + ':' + archive, {})
        self._store.setdefault('src-date', datetime.now(timezone.utc))
        self._store.setdefault('bin-date', datetime.now(timezone.utc))
        self.lp = lp
        self.ks = ks
        self.reference = archive
        self.archive = lp.archives.getByReference(reference=archive)

        # Make a quick lookup for all valid source packages.
        self.source_packages = {}
        for series in self.ks.series:
            for source in series.sources:
                for package in source.packages:
                    self.source_packages["{}:{}".format(series.codename, package.name)] = source.name

        # Validate that this archive is sufficiently public.
        try:
            self.archive.getPublishedBinaries(order_by_date=True,
                status='Published', created_since_date=self.bin_date)
        except Unauthorized:
            raise MonitorIncompatible()

    src_date = MonitorStoreAttr('src-date')
    bin_date = MonitorStoreAttr('bin-date')

    def changed(self):
        sources = set()
        things_seen = set()

        #print(self.archive, self.src_date, self.bin_date)

        # Accumulate new source package publications.
        changed = self.archive.getPublishedSources(order_by_date=True,
            status='Published', created_since_date=self.src_date)
        if len(changed) > 0:
            self.src_date = changed[0].date_published
            for pub in changed:
                print("S", pub, pub.date_published, pub.distro_series_link,
                    pub.source_package_name, pub.source_package_version)
                series_name = pub.distro_series_link.split('/')[-1]
                series_source_key = "{}:{}".format(series_name, pub.source_package_name)
                if series_source_key not in self.source_packages:
                    continue
                sources.add("{}:{}".format(series_name,
                    self.source_packages[series_source_key]))

        # Accumulate new binary package publications.
        changed = self.archive.getPublishedBinaries(order_by_date=True,
            status='Published', created_since_date=self.bin_date)
        if len(changed) > 0:
            self.bin_date = changed[0].date_published
            for pub in changed:
                #print("B?", pub, pub.date_published, pub.binary_package_name,
                #    pub.binary_package_version, pub.distro_arch_series_link)
                # All binary packages in a build is associated with the same source.
                if pub.build_link in things_seen:
                    continue
                things_seen.add(pub.build_link)
                print("B", pub, pub.date_published,
                    pub.distro_arch_series_link, pub.build.source_package_name,
                    pub.binary_package_version)
                series_name = pub.distro_arch_series_link.split('/')[-2]
                series_source_key = "{}:{}".format(series_name, pub.build.source_package_name)
                if series_source_key not in self.source_packages:
                    continue
                sources.add("{}:{}".format(series_name,
                    self.source_packages[series_source_key]))

        #print("SOURCES", sources)
        #print("APW", self._backing_store)
        return sources

    def __str__(self):
        return "Launchpad Archive Monitor {}".format(self.reference)


class MonitorFactory:

    def __init__(self, lp=None, ks=None, bs=None):
        self._lp = lp
        self._ks = ks
        self._bs = bs

    @property
    def lp(self):
        if self._lp is None:
            self._lp = Launchpad(False).default_service.launchpad
        return self._lp

    @property
    def ks(self):
        if self._ks is None:
            self._ks = KernelSeries()
        return self._ks

    @property
    def bs(self):
        if self._bs is None:
            self._bs = MonitorStore('swm-publishing.yaml')
        return self._bs

    def kernel_series_archives(self):
        # Find out which archives we may be publishing to and which
        # series/package combinations are interesting to us.
        archive_names = set()
        for series in self.ks.series:
            for source in series.sources:
                if source.supported or source.development:
                    if not source.routing:
                        continue
                    for pocket in ('build', 'proposed', 'signing', 'updates', 'security',
                            'release'):
                        dest = source.routing.lookup_destination(pocket)
                        if not dest:
                            continue
                        for route in dest:
                            archive_names.add(route[0])

        monitors = []
        for archive_name in archive_names:
            monitors.append(MonitorLaunchpadArchive(archive_name, lp=self.lp, ks=self.ks, bs=self.bs))

        return monitors

    def sync(self):
        self.bs.sync()

    def __str__(self):
        return "Private Archive Monitor {}".format(self.reference)


if __name__ == '__main__':
    factory = MonitorFactory()

    monitors = []
    monitors += factory.kernel_series_archives()

    command = None

    # Look for updates in each monitor.
    changed = set()
    for monitor in monitors:
        print("***", monitor)
        sys.stdout.flush()
        new = monitor.changed()
        if len(new) > 0:
            print(monitor, "CHANGED", list(new))
        sys.stdout.flush()
        changed = changed | new
    print("CHANGED", changed)

    sys.stdout.flush()

    if len(changed) > 0:
        cmd = ['./swm-cron', '--dependants'] + list(changed)
        command = Popen(cmd)
        print("COMMAND STARTED", command.pid)
        sys.stdout.flush()
        status = command.wait()
        print("COMMAND COMPLETE", status)
        if status != 0:
            sys.exit(1)

    # All is done, update the backing store.
    factory.sync()
