#!/usr/bin/env python

from os                     import system, getenv, path
from sys                    import exit
from subprocess             import Popen, PIPE, call
from optparse               import OptionParser
from tempfile               import NamedTemporaryFile
from ktl.git                import Git

#
# The mail will be sent to this list of receipients.
#
tolist = [
            "linux-kernel@vger.kernel.org",
            "stable@vger.kernel.org",
            "kernel-team@lists.ubuntu.com"
         ]
cclist = [
            "lwn@lwn.net",
         ]

#
# Get the default name and email address from git config
#
DefaultName  = Git.config("user.name")
DefaultEmail = Git.config("user.email")

if DefaultEmail != "":
    if DefaultName != "":
        DefaultFrom = DefaultName + " <" + DefaultEmail + ">"
    else:
        DefaultFrom = DefaultEmail
else:
    DefaultFrom = ""

#
# Setup the command line parser and run it.
#
OptParser = OptionParser(
    "Usage: %prog [options]",
    epilog = "This command is intended to be run after a stable "
             "update has been released. It will send out a mail that "
             "announces that it is available now."
)
OptParser.add_option(
    "--dry-run", dest="dryrun", action="store_true", default=False,
    help="run it test mode and do not really send out any mail. This will "
         "also cause the mail body be written to stdout."
)
OptParser.add_option(
    "--from", dest="sender", action="store", default=DefaultFrom,
    help="sets the sender of the announcement email, default is "
         "git config user.name and user.email (%default)."
)
OptParser.add_option(
    "--previous_release", dest="previous_release", action="store", default="",
    help="The tag or commit of the top of the previous stable release, eg."
         "v3.16.7-ckt1, we will consider stable patches from that up to HEAD."
)
OptParser.add_option(
    "--new_version", dest="new_version", action="store", default="",
    help="The version for the set of stable patches to be released. "
         "It's the new version to be displayed in subject/body of the email"
         "announcement sent out, eg. 3.16.7-ckt2"
)
OptParser.add_option(
    "--edit", dest="edit", action="store_true", default=False,
    help="allow editing the cover-letter by launching an editor.  Usually "
         "not needed, but may be useful to edit the last release email "
         "(i.e., when a kernel reaches EOL)"
)
(opts, args) = OptParser.parse_args()

#
# Has the sender been set correctly?
#
if opts.sender == "":
    print "EE: No mail sender was set!"
    exit(1)

#
# Check the required parameters
#
if opts.previous_release == "":
    print "EE: No --previous_release given!"
    exit(1)
if opts.new_version == "":
    print "EE: No --new_version given!"
    exit(1)

#
# Prevent me from calling this from anywhere.
#
if not path.isdir(".git") and not (path.isdir("hooks") and path.isdir("refs")):
    print "EE: Need to be called from git top-level directory!"
    exit(1)

#
# Look at the topmost commit message and make sure this looks like a release
# commit.
#
cmd = "git log --pretty='%s' -1"
tag = Popen(cmd, shell=True, stdout=PIPE).stdout.readline().rstrip()

if not tag.startswith("Linux "):
    print "EE: Latest commit does not seem to be a release!"
    exit(1)

#
# Versions/range to use on emails
#
tmp = tag.split(" ")[1]
for line in open("Makefile", "r").readlines():
    line = line.strip()
    if line.startswith("VERSION"):
        v1 = line.split()[-1]
        continue
    if line.startswith("PATCHLEVEL"):
        v2 = line.split()[-1]
        continue
    if line.startswith("SUBLEVEL"):
        v3 = line.split()[-1]
        continue
    if line.startswith("EXTRAVERSION"):
        v4 = line.split()[-1]
        break
if v1 == "1" or v2 == "2":
    basever = "%s.%s.%s" % (v1, v2, v3)
else:
    basever = "%s.%s"  % (v1, v2)
ann_ver = "%s.y-ckt" % basever
vstable = opts.new_version
rangestart = opts.previous_release
rangeend = "v%s" % vstable

#
# Pre-contruct the contents of the mail
#
mailbody = []
for entry in tolist:
    mailbody.append("To: " + entry)
for entry in cclist:
    mailbody.append("Cc: " + entry)
mailbody.extend([
    "From: " + opts.sender,
    "Subject: [%s stable] Linux %s" % (ann_ver, vstable),
    "X-Extended-Stable: %s" % (basever),
    "",
    "I am announcing the release of the Linux %s kernel." % (vstable),
    "",
    "The updated %s.y-ckt tree can be found at: " % (basever),
    "  git://kernel.ubuntu.com/ubuntu/linux.git linux-%s.y" % (basever),
    "and can be browsed at:",
    "  http://kernel.ubuntu.com/git?p=ubuntu/linux.git;h=refs/heads/linux-%s.y;a=shortlog" % (basever),
    "",
    "The diff from %s is posted as a follow-up to this email." % (rangestart),
    "",
    "The %s.y-ckt extended stable tree is maintained by the Canonical Kernel Team."
    % (basever),
    "For more info, see https://wiki.ubuntu.com/Kernel/Dev/ExtendedStable",
    "",
    " -" + opts.sender.split()[0],
    "",
    "-- ",
])

#
# Add a list of included patches and the diff between this and the last
# release.
#

cmd = "git diff --stat " + rangestart + ".." + rangeend
for line in Popen(cmd, shell=True, stdout=PIPE).stdout.readlines():
    mailbody.append(line.rstrip())
mailbody.append("")
cmd = "git shortlog " + rangestart + ".." + rangeend
for line in Popen(cmd, shell=True, stdout=PIPE).stdout.readlines():
    mailbody.append(line.rstrip())

#
# Now create a temporary file and fill it with the mailbody.
#
try:
    fp = NamedTemporaryFile(prefix="mail-")
    dp = NamedTemporaryFile(prefix="mail-")
except:
    raise

for line in mailbody:
    fp.write(line + "\n")
fp.flush()
dp.write("From: " + opts.sender + "\n")
dp.write("Subject: Re: [%s stable] Linux %s\n" % (ann_ver, vstable))
dp.write("X-Extended-Stable: %s\n\n" % (basever))
dp.flush()
cmd = "git diff " + rangestart + ".." + rangeend + " >> " + dp.name
system(cmd)

#
# Allow the user to edit the cover letter
#
if opts.edit == True:
    # Get editor to be used for opening the cover letter
    editor = getenv("NSR_EDITOR")
    if not editor:
        editor = "/usr/bin/editor"
    try:
        call([editor, fp.name])
    except:
        print("%s not found to edit cover letter for the patch series."
              % editor)
        print("Please install an editor, if your system doesn't have")
        print(" /usr/bin/editor setup as alternatives, you can set the")
        print(" NSR_EDITOR environment variable pointing to the editor")
        print(" executable (eg. vim, nano, etc.)")
        exit(1)

#
# Construct the call to git send-email
#
cmd = "git send-email --suppress-cc all --8bit-encoding=UTF-8 --from \""
cmd += opts.sender + "\""
for line in tolist:
    cmd += " --to \"" + line + "\""
for line in cclist:
    cmd += " --cc \"" + line + "\""
if opts.dryrun:
    cmd += " --dry-run"
cmd += " " + fp.name + " " + dp.name

system(cmd)

if opts.dryrun:
    system("cat " + fp.name)
    system("cat " + dp.name)

fp.close()
dp.close()

# vi:set ts=4 sw=4 expandtab:
