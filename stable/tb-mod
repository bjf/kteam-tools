#!/usr/bin/env python3
#

import sys
import os
sys.path.append(os.path.join('..'))
sys.path.append(os.path.join(os.path.expanduser('~'), '.python3'))

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from logging                            import basicConfig, INFO, DEBUG
import json

from datetime                           import datetime
from wfl.launchpad                      import Launchpad
from wfl.bug                            import WorkflowBug
from wfl.log                            import cdebug, center, cleave

# TheApp
#
class TheApp():
    # __init__
    #
    def __init__(s, args):
        '''
        '''
        center(s.__class__.__name__ + '.__init__')
        s.args = args
        s._lp = None
        cleave(s.__class__.__name__ + '.__init__')

    @property
    def lp(s):
        if s._lp is None:
            cdebug(" . Connecting to Launchpad")
            s._lp = Launchpad(False)
        return s._lp

    # __get_relevant_task
    #
    def __get_relevant_task(s, bug):
        center(s.__class__.__name__ + '.__get_relevant_task')
        retval = None
        for t in bug.tasks:
            task       = t.bug_target_name
            p = task.replace(' (Ubuntu)', '')
            print(p)
            if p in ['kernel-sru-workflow', 'kernel-development-workflow']:
                retval = t
                break
        cleave(s.__class__.__name__ + '.__get_relevant_task')
        return retval

    # __verbose_bug_info
    #
    def __verbose_bug_info(s, bug):
        print(" ")
        print("    %s: %s" % (bug.id, bug.title))
        print(" ")

        tags = ""
        for t in bug.tags:
            tags += t
            tags += " "
        print("        Tags:")
        print("            %s" % (tags))

        tasks = bug.tasks
        print("        Tasks:")
        for task in tasks:
            print("            %45s %20s %20s" % (task.bug_target_name, task.status, task.importance))

    # date_to_string
    #
    def date_to_string(s, date):
        return date.strftime("%A, %d. %B %Y %H:%M UTC")

    # string_to_date
    #
    def string_to_date(s, date):
        return datetime.strptime(date, '%A, %d. %B %Y %H:%M UTC')

    # bug_needs_attention
    #
    def bug_needs_attention(s, bug, package, db):
        retval = False

        if bug.id in db['bug-collections'][package]['bugs']:
            retval = True
        else:
            retval = False

        return retval

    # main
    #
    def main(s):
        center(s.__class__.__name__ + '.main')
        try:
            WorkflowBug.sauron = True
            bug = WorkflowBug(s.lp.default_service, s.args.bug)

            if s.args.tags is not None:
                for tag in s.args.tags:
                    bug.lpbug.tags.append(tag)

            if s.args.task is not None:
                task = bug.tasks_by_name[s.args.task.lower()]
                task.status = s.args.status

            if s.args.release_ready:
                # All testing tasks need to be either Invalid or Fix Released
                #
                for t in ['automated-testing', 'certification-testing', 'regression-testing', 'verification-testing']:
                    task = bug.tasks_by_name[t]
                    if task.status != 'Invalid':
                        task.status = 'Fix Released'

                # Add the necessary tags
                #
                for t in ['regression-testing-passed']:
                    bug.lpbug.tags.append(t)

                # Remove the necessary tags
                #
                tag = 'block-proposed-%s' % bug.series
                bug.lpbug.tags.remove(tag)

            if s.args.testing_complete:
                # Add the necessary tags
                #
                for t in ['regression-testing-passed']:
                    bug.lpbug.tags.append(t)


        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            print("Keyboard interrupt")
            pass

        cleave(s.__class__.__name__ + '.main')
        return

if __name__ == '__main__':
    # Command line argument setup and initial processing
    #
    app_description = '''
    '''
    app_epilog = '''
examples:
    tr-mod 1555809 --tags=qa-testing-passed
    tr-mod 1555809 Verification-testing 'Fix Released'
    '''
    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('--debug',  action='store_true', default=False, help='Print out a lot of messages about what is going on.')
    parser.add_argument('--tags', metavar='TAGS', nargs='*',                 default=None, help='')
    parser.add_argument('bug',  metavar='BUG', nargs="?",                  default=None, help='')
    parser.add_argument('task',  metavar='TASK', nargs="?",                  default=None, help='')
    parser.add_argument('status',  metavar='STATUS', nargs="?",                  default=None, help='')

    parser.add_argument('--testing-complete',  action='store_true', default=False, help='')
    parser.add_argument('--release-ready',  action='store_true', default=False, help='')

    args = parser.parse_args()

    if args.task is not None:
        if args.status is None:
            print('  ** Error: Both task and status must be specified')
            exit(-1)

    # If logging parameters were set on the command line, handle them
    # here.
    #
    log_format = "%(message)s"
    if args.debug:
        basicConfig(level=DEBUG, format=log_format)
    else:
        basicConfig(level=INFO, format=log_format)

    app = TheApp(args)
    exit(app.main())

# vi:set ts=4 sw=4 expandtab:
