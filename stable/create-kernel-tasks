#!/usr/bin/python3

import os
import sys
import argparse
import logging

from datetime           import datetime

sys.path.append(os.path.realpath(
    os.path.join(os.path.dirname(__file__), os.pardir, 'libs')))

from ktl.log            import Clog, cerror, cwarn, cinfo, cdebug
from ktl.kernel_series  import KernelSeries
from ktl.tracking_bug2  import TrackingBugs, TrackingBugError
from ktl.cycleboard     import CycleBoard, CycleBoardError

class Task():
    def __init__(self, taskset, ks_source, ks_snap=None):
        self.taskset   = taskset
        self.ks_source = ks_source
        self.ks_snap   = ks_snap
        self.create    = False
        self.tb        = None
        self.subtasks  = []
        self.level     = 0

    def __repr__(self):
        '''
        Represents a task as a string for printing.
        '''
        ret = ''

        i = self.level + 1
        while i > 0:
            ret += '  '
            i -= 1

        cn = self.ks_source.series.codename
        pfx = '='
        if self.create is True:
            pfx = '+'
        if self.ks_snap is not None:
            ret += '{} {}/{}/{}'.format(pfx, cn, self.ks_source.name, self.ks_snap.name)
        else:
            ret += '{} {}/{}'.format(pfx, cn, self.ks_source.name)
        if self.tb is None:
            ret += ' (None)'
        else:
            ret += ' (LP: #{})'.format(self.tb.id)
        if self.ks_snap is not None:
            ret += ' [snap]'
        else:
            ret += ' [deb]'

        for subtask in self.subtasks:
            ret += '\n{}'.format(subtask)

        return ret

    @property
    def sourcetype(self):
        if self.ks_snap is None:
            return 'deb'
        else:
            return 'snap'

    def AddSubtask(self, task):
        task.level = self.level + 1
        self.subtasks.append(task)

        return task

    def CreateTrackingBugs(self, dryrun=False):
        new_tbids = []
        new_tbid  = None
        for subtask in self.subtasks:
            new_tbids.extend(subtask.CreateTrackingBugs(dryrun=dryrun))

        cn = self.ks_source.series.codename
        if self.sourcetype == 'deb':
            sn = self.ks_source.name
            bv = 'debs'
        else:
            sn = self.ks_snap.name
            bv = 'snap-debs'

        ts = self.taskset
        spintag = '{}-{}'.format(ts.cycletag, ts.spin_nr)
        if self.create:
            old_tb = self.tb

            cinfo('Creating {} tracking bug for {}/{}[{}]...'.format(bv, cn, sn, spintag))
            if dryrun is True:
                new_tbid = ts.fake_id
                ts.fake_id += 1
            else:
                if bv == 'debs':
                    self.tb = ts.tbs.create(cn, sn, variant=bv)
                else:
                    self.tb = ts.tbs.create(cn, self.ks_source.name, variant=bv, name=sn)
                self.tb.set_cycle_and_spin(ts.cycletag, ts.spin_nr)
                new_tbid = self.tb.id
            cinfo('  + created LP: #{}'.format(new_tbid))

            if old_tb is not None:
                # Inherit all the derivatives set in tracking bug being replaced
                for tbid in old_tb.derivative_bug_ids:
                    if tbid not in ts.tbs:
                        ts.tbs.add(tbid)
                    tb = ts.tbs[tbid]
                    cinfo('  + derivative {}/{}'.format(tb.target_series, tb.target_package))
                    if dryrun is False:
                        self.tb.derivative_add(tb)

                # If the tracking bug being duplicated was linked to a master bug, then
                # unlink it from there.
                if old_tb.master_bug_id is not None:
                    # Not expecting at this stage to miss that master bug from the set but
                    # as it is easy to fix up, just do it.
                    mbid = old_tb.master_bug_id
                    if mbid not in ts.tbs:
                        cwarn('  ! LP: #{} is not loaded, yet. Adding now.'.format(mbid))
                        ts.tbs.add(mbid)
                    mb = ts.tbs[mbid]
                    if old_tb.id in mb.derivative_bug_ids:
                        cinfo('  - remove LP: #{} from LP: #{}'.format(old_tb.id, mbid))
                        if dryrun is False:
                            mb.derivative_remove(old_tb)

                if old_tb.wf_status_get() == 'Fix Released':
                    cinfo('  - old task closed, skipping duplication')
                else:
                    cinfo('  - duplicate LP: #{} to LP: #{}'.format(old_tb.id, new_tbid))
                    if dryrun is False:
                        try:
                            old_tb.make_duplicate_of(self.tb)
                        except TrackingBugError as e:
                            cerror('  - duplication failed: {}'.format(e.msg))

        # Add the tracking bugs of the subtasks to this tasks tracking bug
        # as derivatives.
        for tbid in new_tbids:
            if dryrun is False:
                tb = ts.tbs[tbid]
                cinfo('{}/{} + derivative {}/{}'.format(cn, sn, tb.target_series, tb.target_package))
                self.tb.derivative_add(tb)
            else:
                cinfo('{}/{} + derivative LP: #{}'.format(cn, sn, tbid))

        if new_tbid is None:
            return []
        else:
            return [new_tbid]

    def FinalizeTrackingBugs(self, dryrun=False):
        for subtask in self.subtasks:
            subtask.FinalizeTrackingBugs(dryrun=dryrun)
        if self.create is True:
            cn = self.ks_source.series.codename
            if self.sourcetype == 'deb':
                sn = self.ks_source.name
            else:
                sn = self.ks_snap.name
            cinfo('Setting {}/{} workflow status in-progress.'.format(cn, sn))
            if dryrun is False:
                self.tb.wf_status_set('In Progress')

    def CreateCards(self, dryrun=False):
        if self.create is True:
            cn = self.ks_source.series.codename
            sn = self.ks_source.name
            sp = self.taskset.spin_nr
            cb = self.taskset.board
            if self.sourcetype == 'deb':
                card_txt = 'Crank (#{}) {}/{} kernel'.format(sp, cn, sn)
                card_dsc = 'Use cranky tools and process to get the kernel set uploaded.'
                if self.ks_source.series.esm is True:
                    card_dsc += ' Note the different location and requirements for ESM!'
                cinfo('Create "{}" card'.format(card_txt))
                if dryrun is False:
                    cb.add_card(card_txt, card_dsc)
            elif self.sourcetype == 'snap':
                snn = self.ks_snap.name
                pt = self.ks_snap.publish_to
                card_txt = 'Produce (#{}) {}/{}/{} snap'.format(sp, cn, sn, snn)
                card_dsc = 'Use cranky-update-snap in related branch and push with new tag.'
                cinfo('Create "{}" card'.format(card_txt))
                cdebug('  Desc: {}'.format(card_dsc))
                if dryrun is False:
                    cb.add_card(card_txt, card_dsc)

                for risk in ['candidate', 'stable']:
                    if self.ks_snap.promote_to_risk(risk) is True:
                        # For the summary just check for the first track of whichever
                        # arch comes first.
                        for arch in pt.keys():
                            track = pt[arch][0]
                            break
                        if '-' in track:
                            track = track.split('-')[0]
                        if track == 'latest':
                            track = risk
                        else:
                            track = '{}/{}'.format(track, risk)
                        card_txt  = 'Release (#{}) {}/{}/{} snap '.format(sp, cn, sn, snn)
                        card_txt += 'to {} channel'.format(track)
                        card_dsc  = 'When task switches to "confirmed" state, release '
                        card_dsc += 'to {} channel.'.format(track)
                        cinfo('Create "{}" card'.format(card_txt))
                        cdebug('  Desc: {}'.format(card_dsc))
                        if dryrun is False:
                            cb.add_card(card_txt, card_dsc)

        for subtask in self.subtasks:
            subtask.CreateCards(dryrun=dryrun)


class TaskSet():
    def __src_wanted(self, ks_source, src_list):
        return (len(src_list) == 0 or ks_source.name in src_list)

    def __src_get_origin(self, ks_source):
        origin = ks_source.derived_from
        if origin:
            if origin.derived_from:
                origin = self.__src_get_origin(origin)
        return origin

    def __task_match_tb(self, task):
            series  = task.ks_source.series.codename
            source  = task.ks_source.name
            matchtb = None

            if task.ks_snap is not None:
                source = '{}/{}'.format(source, task.ks_snap.name)
            bug_ids = self.tbs.get_series_package(series, source)

            if bug_ids is not None:
                # At this point there might be multiple bugs returned (for example one
                # from a previous cycle which has not yet cleared away).
                for bug_id in bug_ids:
                    tb = self.tbs[bug_id]
                    if tb.cycle != self.cycletag:
                        continue
                    if task.sourcetype == 'snap':
                        variant = tb.wf_get_property('variant')
                        if variant is None or variant != 'snap-debs':
                            continue
                    # if task.create is True and self.spin_nr is not None:
                    #    if tb.spin_nr < self.spin_nr:
                    #        continue
                    if matchtb is None:
                        matchtb = tb
                    elif matchtb.spin_nr == tb.spin_nr:
                        cerror('{} has existing tbs with identical spin number!'.format(task))
                        cerror('- {} vs. {}'.format(matchtb.id, tb.id))
                        sys.exit(2)
                    else:
                        if tb.spin_nr > matchtb.spin_nr:
                            matchtb = tb

            return matchtb

    def __task_match_all_tbs(self, task):
        series = task.ks_source.series.codename
        if series not in self.tbs.series_names:
            cinfo('Adding tracking bugs for {}...'.format(series))
            tags = []
            if self.spin_nr is not None:
                if self.spin_nr > 1:
                    n = self.spin_nr
                    while n > 0:
                        tags.append('kernel-sru-cycle-{}-{}'.format(self.cycletag, n))
                        n = n - 1

            self.tbs.load(series_filter=[series], tag_filter=tags, debug=True)
        task.tb = self.__task_match_tb(task)

        # Next traverse all subtasks and try to find an existing tracking bug
        for subtask in task.subtasks:
            self.__task_match_all_tbs(subtask)

    def __task_add_snaps(self, task):
        ks_source = task.ks_source

        for ks_snap in sorted(ks_source.snaps, key=lambda x: x.name):
            if not ks_snap.repo:
                continue
            subtask = task.AddSubtask(Task(self, ks_source, ks_snap))
            subtask.create = True

    def __add_task_and_ancestors(self, derivative):
        '''
        Internal helper which adds a new task for a source and optionally also creates
        all tasks in its ancestor chain.
        '''
        if derivative.derived_from is None:
            # Top-level task (master kernel) if it is not created already, do that
            # here.
            tkey = derivative.series.codename
            if tkey not in self.tasks:
                self.tasks[tkey] = Task(self, derivative)
            return self.tasks[tkey]

        task = self.__add_task_and_ancestors(derivative.derived_from)
        for t in task.subtasks:
            # If there is already a matching subtask, then hand that one back while
            # unwinding.
            if t.ks_source == derivative:
                return t

        # As there is no subtask defined already, create a fresh one and return it
        # to the caller.
        return task.AddSubtask(Task(self, derivative))

    def __task_check_new(self, task):
        for subtask in task.subtasks:
            try:
                self.__task_check_new(subtask)
            except:
                raise

        if task.create is True and task.tb is not None:
            if self.spin_nr <= task.tb.spin_nr:
                cn = task.ks_source.series.codename
                sn = task.ks_source.name
                raise ValueError('{}/{} already exists as spin #{}'.format(cn, sn, task.tb.spin_nr))

    def __repr__(self):
        '''
        This function is called when a TaskSet is to be displayed as a
        string for printing. At this level it loops over all series
        which are in the task set and calls the format function for
        each task.
        '''
        output = ''

        for ks_series in self.ks_series_list:
            output += '* {}\n'.format(ks_series.codename)
            output += '{}\n'.format(self.tasks[ks_series.codename])

        return output

    def __init__(self, ks_series_list, source_name_list, cycledate, ks=None):
        '''
        Initialize a TaskSet which consists
        ks_series_list = [ KernelSeries.series ... ]
        source_name_list = [ str ... ]
        cycledate = datetime
        ks = Instance of KernelSeries to embed
        '''
        if ks is None:
            ks = KernelSeries()
        self.ks = ks
        self.tbs = None
        self.board = None
        self.cycledate = cycledate
        self.ks_series_list = ks_series_list
        self.tasks = dict()
        self.cycletag = cycledate.strftime('%Y.%m.%d')
        self.spin_nr = None
        self.fake_id = 5550000

        if ks_series_list[0].development:
            self.cycletag = 'd' + self.cycletag

        for ks_series in sorted(ks.series, key=KernelSeries.key_series_name, reverse=True):
            if not ks_series.development and not ks_series.supported:
                continue
            for ks_source in ks_series.sources:
                if not ks_source.supported or ks_source.copy_forward:
                    continue
                if not self.__src_wanted(ks_source, source_name_list):
                    continue
                origin = self.__src_get_origin(ks_source)
                if origin is None:
                    # This handles the base linux sources (top-level tasks). Depending on
                    # the order sources are enumerated it might have been created when adding
                    # one of the sources derived from there.
                    tkey = ks_series.codename
                    if ks_series in ks_series_list:
                        if tkey not in self.tasks:
                            self.tasks[tkey] = Task(self, ks_source)
                        self.tasks[tkey].create = True
                        self.__task_add_snaps(self.tasks[tkey])
                else:
                    # For any derivative, we call a helper which returns a new Task object
                    # that already has been attached to its ancestor chain. Any task which
                    # had to be created (including main tasks) will not be marked for creation
                    # (so there must be an existing tracking bug for that or verification will
                    # fail).
                    if origin.series in ks_series_list:
                        subtask = self.__add_task_and_ancestors(ks_source)
                        subtask.create = True
                        self.__task_add_snaps(subtask)

    def LoadTrackingBugs(self, test=False):
        self.tbs = TrackingBugs(testing=test)

        cinfo('Fetching existing tracking bugs for reality check...')

        for series in self.ks_series_list:
            self.__task_match_all_tbs(self.tasks[series.codename])

    def ValidateTasks(self):
        # When no spin number is provided on the command-line, then pick the
        # next one free.
        if self.spin_nr is None:
            self.spin_nr = 1
            for tbid in self.tbs:
                tb = self.tbs[tbid]
                if tb.cycle == self.cycletag:
                    if tb.spin_nr >= self.spin_nr:
                        self.spin_nr = tb.spin_nr + 1
            cinfo('Auto-selecting spin number: {}'.format(self.spin_nr))
        else:
            # FIXME: What are the constraints when providing a spin number?
            #   - only additional tasks are allowed (no task to create with
            #     an existing tracking bug assigned
            for series in self.tasks:
                try:
                    self.__task_check_new(self.tasks[series])
                except:
                    raise

        # Initial spins (#1) would find no existing tracking bugs but must create
        # the main task. Re-spins may not require to create the main task but must
        # find an existing tracking bug for those.
        for series in self.tasks:
            maintask = self.tasks[series]
            cn = maintask.ks_source.series.codename
            sn = maintask.ks_source.name
            if maintask.create is False and maintask.tb is None:
                raise ValueError('{}/{} has no tracking bug and is not created!'.format(cn, sn))

    def CreateTrackingBugs(self, dryrun=False):
        for ks_series in self.ks_series_list:
            self.tasks[ks_series.codename].CreateTrackingBugs(dryrun=dryrun)

    def FinalizeTrackingBugs(self, dryrun=False):
        for ks_series in self.ks_series_list:
            self.tasks[ks_series.codename].FinalizeTrackingBugs(dryrun=dryrun)

    def CreateCards(self, dryrun=False):
        if dryrun is False and self.board is None:
            self.board = CycleBoard()
            try:
                self.board.lookup_board_id('SRU Cycle {}'.format(self.cycletag))
                self.board.lookup_list_id('Backlog')
            except CycleBoardError as e:
                cerror(e)
                return
        for ks_series in self.ks_series_list:
            self.tasks[ks_series.codename].CreateCards(dryrun=dryrun)


if __name__ == '__main__':

    desc = '''
Create all tasks (tracking bugs and trello cards for a given SRU cycle.
By default this will cover all supported (excluding development) series
and all supported kernel source for each series.
'''

    epilog = '''
Examples:

  $ create-kernel-tasks 2018.09.24

  This would try to add "Crank ..." cards for all supported kernel sources
  to the "SRU Cycle 2018.09.24" board and also create a tracking bug for
  each source. If there are already existing tracking bugs, the next avail-
  able spin number will be calculated and any tracking bug replaced will
  be duplicated agains the new one.

  $ create-kernel-tasks --devel 2018.09.24

  This would skip creating any trello cards and only create tracking bugs.
  Spin number calculation and duplication will be the same as for normal
  SRU cycles but the cycle tag will automatically be prefixed with 'd'.
  Kernel sources can be limited/selected with the --source option but
  the --series option cannot be used together with --devel.
'''

    formatter = argparse.RawDescriptionHelpFormatter
    parser = argparse.ArgumentParser(description=desc, epilog=epilog,
                                     formatter_class=formatter)
    parser.add_argument('--dry-run', action='store_true', default=False,
                        help='do not make any changes, ' +
                        'just show what would be done')
    parser.add_argument('--force-nocards', action='store_true', default=False,
                        help='forcefully disable the creation of Trello cards. This is the default in --devel mode')
    grp1 = parser.add_mutually_exclusive_group()
    grp1.add_argument('--devel', action='store_true', default=False,
                      help='run task creation in development mode')
    grp1.add_argument('--series', action='append', default=[], metavar='<series>',
                      help='limit task creation to the provided series. This means the series which a master is in, so limiting to one series might also create tasks in a different series if a source is a derivative of the master in the specified one')
    parser.add_argument('--source', action='append', default=[], metavar='<source',
                        help='limit task creation to the provided sources')
    parser.add_argument('--spin', action='store', metavar='<spin nr>', default=None, type=int,
                        help='override the spin number to be used. Only new tasks are allowed in this mode!')
    parser.add_argument('--test', action='store_true', default=False,
                        help='create test tracking bugs (using a different live tag)')
    parser.add_argument('--debug', action='store_true', default=False,
                        help='output debug level logs')
    parser.add_argument('cycledate', metavar='<cycle date>',
                        help='date of this cycle (YYYY.MM.DD). When not in development mode, this has to be a Monday')
    args = parser.parse_args()

    Clog.color = True
    if args.debug:
        logging.basicConfig(level=logging.DEBUG,
                            format='%(levelname)s - %(message)s')
        Clog.dbg = True
    else:
        logging.basicConfig(level=logging.INFO, format='%(message)s')

    # Prepare a list of (originating) series to work on
    ks = KernelSeries()
    ks_series_list = []
    if args.devel:
        ks_series = ks.lookup_series(development=True)
        if ks_series is None:
            cerror('No development series found!')
            sys.exit(1)
        ks_series_list.append(ks_series)
    else:
        for ks_series in sorted(ks.series, key=KernelSeries.key_series_name, reverse=True):
            if len(args.series) == 0:
                if not ks_series.supported or ks_series.development:
                    continue
                ks_series_list.append(ks_series)
            else:
                if ks_series.codename in args.series:
                    if ks_series.development:
                        cerror('Development series tasks must be created using --devel')
                        sys.exit(1)
                    ks_series_list.append(ks_series)

    # Sanity check whether --source only is used together with one series
    if len(args.source) > 0 and len(ks_series_list) != 1:
        cerror('The --source filter is only allowed when limited to one series')
        sys.exit(1)

    # Sanity check the cycle date
    try:
        cycledate = datetime.strptime(args.cycledate, '%Y.%m.%d')
    except:
        cerror('The provided cycle date could not be parsed!')
        sys.exit(1)
    if not ks_series_list[0].development:
        if cycledate.isoweekday() != 1:
            cerror('The provided date is not a Monday when not using --devel!')
            sys.exit(1)

    # Now collect all sources (deb or snap) that need tasks
    ts = TaskSet(ks_series_list, args.source, cycledate, ks)

    # If the taskset is empty, then your choice was poor...
    if len(ts.tasks) == 0:
        cerror('The given selection did not result in any matched task')
        sys.exit(1)

    if args.spin is not None:
        ts.spin_nr = args.spin

    print(ts)
    ts.LoadTrackingBugs(test=args.test)
    print(ts)
    try:
        ts.ValidateTasks()
    except ValueError as e:
        cerror('Validation: failed with "{}"!'.format(e))
        sys.exit(1)
    cinfo('Validation: passed')
    if args.force_nocards is False and args.devel is False:
        ts.CreateCards(dryrun=args.dry_run)
    ts.CreateTrackingBugs(dryrun=args.dry_run)
    ts.FinalizeTrackingBugs(dryrun=args.dry_run)

# vi:set ts=4 sw=4 expandtab syntax=python:
