#!/usr/bin/env python3
#

import sys
import os

sys.path.append(os.path.realpath(os.path.join(os.path.dirname(__file__), '..', 'py3')))

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from ktl.kernel_series                  import KernelSeries
from ktl.tracking_bug                   import TrackingBug
from lpltk.LaunchpadService             import LaunchpadService, LaunchpadServiceError

# Crankers
#
class Crankers():
    '''
    '''

    # __init__
    #
    def __init__(s, args):
        s.args = args

    def series_wanted(s, series):
        return (not series.development and
                (len(s.args.series) == 0 or series.codename in s.args.series))

    def source_wanted(s, source):
        return (len(s.args.source) == 0 or source.name in s.args.source)

    # tracked_packages
    #
    def tracked_packages(s):
        '''
        Using the ktl/ubunty.py data create a dictionary of each series and all of the packages
        that need tracking bugs created for them.

        (xenial,linux):
            [(xenial,linux-aws), (xenial,linux-raspi2),
             (xenial,linux-snapdragon), (trusty,linux-lts-xenial)]
        '''
        retval = {}
        kernel_series = KernelSeries()
        for series in sorted(kernel_series.series, key=lambda s: s.codename):
            if not series.supported or series.development:
                continue
#            if len(s.args.series) != 0 and series.name not in s.args.series:
#                continue

            for source in series.sources:
                if not source.supported or source.copy_forward:
                    continue
                if not s.source_wanted(source):
                    continue
                derived_from = source.derived_from
                if not derived_from:
                    if s.series_wanted(series):
                        retval.setdefault((series.codename, source.name), [])
                else:
                    if s.series_wanted(derived_from.series):
                        retval_series = retval.setdefault((derived_from.series.codename, derived_from.name), [])
                        retval_series.append((series.codename, source.name))
        return retval

    # add_cycle_tag
    #
    def add_cycle_tag(s, bug, tag):
        tags = bug.tags
        tags.append(tag)
        bug.tags = tags
        bug.lp_save()

    # tb
    #
    @property
    def tb(s):
        '''
        To work around LP issues with keeping objects around for a while and to help
        make things a little more robust, recreate the LP connection and a new TrackingBug
        instance each time we want to open/create a new tracking bug.
        '''
        # We instantiate a new LP instance at this point because it seems LP has
        # problems if you try to keep the same one around too long.
        #
        try:
            defaults = {
                'launchpad_client_name' : 'start-sru-cycle',
            }
            if s.args.staging:
                defaults['launchpad_services_root'] = 'qastaging'
            lp = LaunchpadService(defaults)
            return(TrackingBug(lp, staging=s.args.staging))
        except LaunchpadServiceError as e:
            print(e.msg)
            raise

    # main
    #
    def main(s):
        retval = 1
        try:
            data = s.tracked_packages()
            cycle_tag = 'kernel-sru-cycle-' + s.args.cycle

            for (series, master_package) in sorted(data):
                print('%s' % series)
                print('    ' + master_package)

                print('        %s:%s' % (series, master_package))
                if not s.args.dryrun:
                    master_bug = s.tb.open(master_package, '<version to be filled>', True, None, series)
                    for task in master_bug.tasks:
                        # Move the primary package to Confirmed, link-to-tracker and
                        # shanky will keep on top of the others and move them as needed.
                        if task.bug_target_name.endswith('/prepare-package'):
                            task.status = 'Confirmed'
                    master_bug.tags.append(cycle_tag)
                    master_bug.tags.append('kernel-sru-master-kernel')

                derivatives = []
                backports = []
                for (derivative_series, derivative_package) in data[(series, master_package)]:
                    print('        %s:%s' % (derivative_series, derivative_package))
                    if not s.args.dryrun:
                        bug = s.tb.open(derivative_package, '<version to be filled>', True, master_bug.id, derivative_series)
                        if bug is None:
                            print('     -> EE: Bug creation failed (does the package exist in the archive?)!')
                            continue
                        bug.tags.append(cycle_tag)
                        if series == derivative_series:
                            derivatives.append('bug {} ({})'.format(str(bug.id), derivative_package))
                            bug.tags.append('kernel-sru-derivative-of-%s' % master_bug.id)
                        else:
                            backports.append('bug {} ({})'.format(str(bug.id), derivative_package))
                            bug.tags.append('kernel-sru-backport-of-%s' % master_bug.id)

                if not s.args.dryrun:
                    description = master_bug.description
                    description += '\n'
                    description += 'backports: %s\n' % ', '.join(backports)
                    description += 'derivatives: %s\n' % ', '.join(derivatives)
                    master_bug.description = description

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            print("Aborting ...")

        if retval > 0:
            print("")
            print("Due to the above error(s), this script is unable to continue and is terminating.")
            print("")

        return retval

if __name__ == '__main__':
    app_description = '''
start-sru-cycle creates all of the tracking bugs for a kernel SRU cycle. It
can also be used to create a subset of the tracking bugs if only one series
is being re-spun.
    '''

    app_epilog = '''
Examples:
    start-sru-cycle 2018.01.01-1
    start-sru-cycle 2018.02.20-3 --series artful
    '''

    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('cycle',  metavar='cycle', help='The sru cycle tag to be applied to the bugs that are created. The format is YYYY.MM.DD-# where the final "-#" is the spin number. If this is the initial start of a new SRU cycle the spin number will be 1 and is incremented for every re-spin. (e.g. \'2017.04.04-1\').')
    parser.add_argument('--series', action='append', default=[], metavar='series', help='Only creates tracking bugs for the specified series. This includes the main kernel and all of it\'s derivatives. Can be used multiple times.')
    parser.add_argument('--source', action='append', default=[], metavar='source', help='Only create tracking bugs for the specified source package(s). Requiers exactly one series argument to be given. This option can be used multiple times.')
    parser.add_argument('--staging', action='store_true', default=False, help='Use the staging LP server to create the bug. This is just for testing and will go away when the staging database is reset.')
    parser.add_argument('--dry-run', '--dryrun', action='store_true', default=False, help='Make no permanent changes.', dest='dryrun')

    args = parser.parse_args()

    if len(args.source) > 0 and len(args.series) != 1:
        print("Specifying sources only allowed for a single series")
        exit(1)

    # log_format = "%(message)s"
    # basicConfig(level=DEBUG, format=log_format)
    # Clog.dbg = True

    exit(Crankers(args).main())

# vi:set ts=4 sw=4 expandtab syntax=python:
