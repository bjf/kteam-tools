#!/usr/bin/env python3
#

import sys
import os

sys.path.append(os.path.realpath(os.path.join(os.path.dirname(__file__), '..', 'py3')))

from argparse                           import ArgumentParser, RawDescriptionHelpFormatter
from ktl.ubuntu                         import Ubuntu
from ktl.tracking_bug                   import TrackingBug
from lpltk.LaunchpadService             import LaunchpadService, LaunchpadServiceError

# Crankers
#
class Crankers():
    '''
    '''

    # __init__
    #
    def __init__(s, args):
        s.args = args

    # tracked_packages
    #
    def tracked_packages(s):
        '''
        Using the ktl/ubunty.py data create a dictionary of each series and all of the packages
        that need tracking bugs created for them.

        xenial:
            linux:
                'derivatives':
                    linux-aws
                    linux-raspi2
                    linux-snapdragon
                'backports':
                    linux-lts-xenial
        '''
        retval = {}
        ubuntu = Ubuntu()
        for series in sorted(ubuntu.index_by_series_name, reverse=True):
            record = ubuntu.index_by_series_name[series]
            if record['supported']:
                if len(s.args.series) != 0 and series not in s.args.series:
                    continue
                retval[series] = {}
                if 'derivative-packages' in record:
                    for package in record['derivative-packages']:
                        retval[series][package] = {}
                        retval[series][package]['derivatives'] = []
                        retval[series][package]['backports']   = []

                        for derivative in record['derivative-packages'][package]:
                            retval[series][package]['derivatives'].append(derivative)

                for entry in ubuntu.db.values():
                    if 'backport-packages' in entry:
                        for bp in entry['backport-packages']:
                            if record['series_version'] == entry['backport-packages'][bp][1]:
                                retval[series][package]['backports'].append((bp, entry['name']))

        return retval

    # add_cycle_tag
    #
    def add_cycle_tag(s, bug, tag):
        tags = bug.tags
        tags.append(tag)
        bug.tags = tags
        bug.lp_save()

    # tb
    #
    @property
    def tb(s):
        '''
        To work around LP issues with keeping objects around for a while and to help
        make things a little more robust, recreate the LP connection and a new TrackingBug
        instance each time we want to open/create a new tracking bug.
        '''
        # We instantiate a new LP instance at this point because it seems LP has
        # problems if you try to keep the same one around too long.
        #
        try:
            defaults = {
                'launchpad_client_name' : 'start-sru-cycle',
            }
            if s.args.staging:
                defaults['launchpad_services_root'] = 'qastaging'
            lp = LaunchpadService(defaults)
            return(TrackingBug(lp, staging=s.args.staging))
        except LaunchpadServiceError as e:
            print(e.msg)
            raise

    # main
    #
    def main(s):
        retval = 1
        try:
            data = s.tracked_packages()
            cycle_tag = 'kernel-sru-cycle-' + s.args.cycle

            for series in sorted(data):
                print('%s' % series)
                for master_project in data[series]:
                    print('    ' + master_project)

                    print('        %s:%s' % (series, master_project))
                    if not s.args.dryrun:
                        master_bug = s.tb.open(master_project, '<version to be filled>', True, None, series)
                        for task in master_bug.tasks:
                            # Move the primary package to Confirmed, link-to-tracker and
                            # shanky will keep on top of the others and move them as needed.
                            if task.bug_target_name.endswith('/prepare-package'):
                                task.status = 'Confirmed'
                        master_bug.tags.append(cycle_tag)
                        master_bug.tags.append('kernel-sru-master-kernel')

                    backports = []
                    for backport_project, backport_series in data[series][master_project]['backports']:
                        print('        %s:%s' % (backport_series, backport_project))
                        if not s.args.dryrun:
                            bug = s.tb.open(backport_project, '<version to be filled>', True, master_bug.id, backport_series)
                            if bug is None:
                                print('     -> EE: Bug creation failed (does the package exist in the archive?)!')
                                continue
                            bug.tags.append(cycle_tag)
                            backports.append('bug {} ({})'.format(str(bug.id), backport_project))
                            bug.tags.append('kernel-sru-backport-of-%s' % master_bug.id)

                    derivatives = []
                    for derivative_project in data[series][master_project]['derivatives']:
                        print('        %s:%s' % (series, derivative_project))
                        if not s.args.dryrun:
                            bug = s.tb.open(derivative_project, '<version to be filled>', True, master_bug.id, series)
                            if bug is None:
                                print('     -> EE: Bug creation failed (does the package exist in the archive?)!')
                                continue
                            bug.tags.append(cycle_tag)
                            derivatives.append('bug {} ({})'.format(str(bug.id), derivative_project))
                            bug.tags.append('kernel-sru-derivative-of-%s' % master_bug.id)

                    if not s.args.dryrun:
                        description = master_bug.description
                        description += '\n'
                        description += 'backports: %s\n' % ', '.join(backports)
                        description += 'derivatives: %s\n' % ', '.join(derivatives)
                        master_bug.description = description

            retval = 0

        # Handle the user presses <ctrl-C>.
        #
        except KeyboardInterrupt:
            print("Aborting ...")

        if retval > 0:
            print("")
            print("Due to the above error(s), this script is unable to continue and is terminating.")
            print("")

        return retval

if __name__ == '__main__':
    app_description = '''
start-sru-cycle creates all of the tracking bugs for a kernel SRU cycle. It
can also be used to create a subset of the tracking bugs if only one series
is being re-spun.
    '''

    app_epilog = '''
Examples:
    start-sru-cycle 2018.01.01-1
    start-sru-cycle 2018.02.20-3 --series artful
    '''

    parser = ArgumentParser(description=app_description, epilog=app_epilog, formatter_class=RawDescriptionHelpFormatter)
    parser.add_argument('cycle',  metavar='cycle', help='The sru cycle tag to be applied to the bugs that are created. The format is YYYY.MM.DD-# where the final "-#" is the spin number. If this is the initial start of a new SRU cycle the spin number will be 1 and is incremented for every re-spin. (e.g. \'2017.04.04-1\').')
    parser.add_argument('--series', action='append', default=[], metavar='series', help='Only the tracking bugs will be created for a single series. This includes the main kernel and all of it\'s derivatives.')
    parser.add_argument('--staging', action='store_true', default=False, help='Use the staging LP server to create the bug. This is just for testing and will go away when the staging database is reset.')
    parser.add_argument('--dry-run', '--dryrun', action='store_true', default=False, help='Make no permanent changes.', dest='dryrun')

    args = parser.parse_args()

    # log_format = "%(message)s"
    # basicConfig(level=DEBUG, format=log_format)
    # Clog.dbg = True

    exit(Crankers(args).main())

# vi:set ts=4 sw=4 expandtab syntax=python:
